<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Paket.Core</name></assembly>
<members>
<member name="T:ProviderImplementation.AssemblyReader.ILCallingConvStatics">
<summary>
 Static storage to amortize the allocation of ILCallingConv.Instance and ILCallingConv.Static
</summary>
</member>
<member name="T:ProviderImplementation.AssemblyReader.ILArgConvention">
<summary>
 Calling conventions.  These are used in method pointer types.
</summary>
</member>
<member name="T:Fake.Globbing">
<summary>
 This module contains a file pattern globbing implementation.
</summary>
</member>
<member name="M:FSharp.Polyfill.AsyncExtensions.Async.StartAsTaskProperCancel.Static``1(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpOption{System.Threading.Tasks.TaskCreationOptions},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
<summary>
 Like StartAsTask but gives the computation time to so some regular cancellation work
</summary>
</member>
<member name="M:FSharp.Polyfill.AsyncExtensions.Async.Parallel.Static``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Control.FSharpAsync{``1})">
<summary>
 Runs both computations in parallel and returns the result as a tuple.
</summary>
</member>
<member name="T:FSharp.Polyfill.AsyncExtensions">
<summary>
 Extensions for async workflows.
</summary>
</member>
<member name="M:SymlinkUtils.delete(System.String)">
<summary>
 delete the symlink only (do not remove files before)
</summary>
</member>
<member name="P:Paket.SemVerInfo.Build">
<summary>
 The optional build no.
</summary>
</member>
<member name="P:Paket.SemVerInfo.PreRelease">
<summary>
 The optional PreRelease version
</summary>
</member>
<member name="P:Paket.SemVerInfo.Patch">
<summary>
 PATCH version when you make backwards-compatible bug fixes.
</summary>
</member>
<member name="P:Paket.SemVerInfo.Minor">
<summary>
 MINOR version when you add functionality in a backwards-compatible manner.
</summary>
</member>
<member name="P:Paket.SemVerInfo.Major">
<summary>
 MAJOR version when you make incompatible API changes.
</summary>
</member>
<member name="T:Paket.SemVerInfo">
<summary>
 Contains the version information.
</summary>
</member>
<member name="T:Paket.PreRelease">
<summary>
 Information about PreRelease packages.
</summary>
</member>
<member name="T:Paket.ResolverStrategy">
<summary>
 Represents a resolver strategy.
</summary>
</member>
<member name="M:Paket.VersionRequirement.Parse(System.String)">
<summary>
 Parses NuGet V2 version range
</summary>
</member>
<member name="M:Paket.VersionRequirement.IsInRange(Paket.SemVerInfo,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Checks wether the given version is in the version range
</summary>
</member>
<member name="M:Paket.VersionRequirement.FormatInNuGetSyntax">
<summary>
 Formats a VersionRequirement in NuGet syntax
</summary>
</member>
<member name="T:Paket.VersionRange">
<summary>
 Represents version information.
</summary>
</member>
<member name="T:Paket.PreReleaseStatus">
<summary>
 Defines if the range accepts prereleases
</summary>
</member>
<member name="T:Paket.VersionRangeBound">
<summary>
 Defines if the range bound is including or excluding.
</summary>
</member>
<member name="P:Paket.TargetProfile.SupportedPlatformsTransitive">
<summary>
 Get all platforms y for which x &gt;= y holds
</summary>
</member>
<member name="M:Paket.TargetProfile.IsSupportedBy(Paket.TargetProfile)">
<summary>
 true when x is supported by y, for example netstandard15 is supported by netcore10
</summary>
</member>
<member name="M:Paket.TargetProfile.IsSmallerThan(Paket.TargetProfile)">
<summary>
 x &lt; y, see y &gt;= x &amp;&amp; x &lt;&gt; y
</summary>
</member>
<member name="M:Paket.TargetProfile.IsBetween(Paket.TargetProfile,Paket.TargetProfile)">
<summary>
 Note that this returns true only when a &gt;= x and x &lt; b holds.
</summary>
</member>
<member name="M:Paket.TargetProfile.IsAtLeast(Paket.TargetProfile)">
<summary>
 true when x is at least (&gt;=) y ie when y is supported by x, for example netcore10 &gt;= netstandard15 as netstandard15 is supported by netcore10.
 Note that this relation is not complete, for example for WindowsPhoneSilverlightv7.0 and Windowsv4.5 both &lt;= and &gt;= are false from this definition as
 no platform supports the other.
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile344">
<summary>
 portable-net45+sl5+win8+wp8+wpa81
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile336">
<summary>
 portable-net403+sl5+win8+wp8+wpa81
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile328">
<summary>
 portable-net40+sl5+win8+wp8+wpa81
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile259">
<summary>
 portable-net45+win8+wp8+wpa81
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile255">
<summary>
 portable-net45+sl5+win8+wpa81
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile240">
<summary>
 portable-net403+sl5+win8+wpa81
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile225">
<summary>
 portable-net40+sl5+win8+wpa81
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile158">
<summary>
 portable-net45+sl5+win8+wp8
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile157">
<summary>
 portable-win81+wp81+wpa81
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile154">
<summary>
 portable-net45+sl4+win8+wp8
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile151">
<summary>
 portable-net451+win81+wpa81
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile147">
<summary>
 portable-net403+sl5+win8+wp8
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile143">
<summary>
 portable-net403+sl4+win8+wp8
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile136">
<summary>
 portable-net40+sl5+win8+wp8
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile111">
<summary>
 portable-net45+win8+wpa81
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile104">
<summary>
 portable-net45+sl4+win8+wp75
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile102">
<summary>
 portable-net403+win8+wpa81
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile96">
<summary>
 portable-net403+sl4+win8+wp75
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile95">
<summary>
 portable-net403+sl4+win8+wp7
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile92">
<summary>
 portable-net40+win8+wpa81
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile88">
<summary>
 portable-net40+sl4+win8+wp75
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile84">
<summary>
 portable-wp81+wpa81
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile78">
<summary>
 portable-net45+win8+wp8
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile49">
<summary>
 portable-net45+wp8
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile47">
<summary>
 portable-net45+sl5+win8
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile46">
<summary>
 portable-net45+sl4+win8
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile44">
<summary>
 portable-net451+win81
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile42">
<summary>
 portable-net403+sl5+win8
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile41">
<summary>
 portable-net403+sl4+win8
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile37">
<summary>
 portable-net40+sl5+win8
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile36">
<summary>
 portable-net40+sl4+win8+wp8
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile32">
<summary>
 portable-win81+wpa81
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile31">
<summary>
 portable-win81+wp81
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile24">
<summary>
 portable-net45+sl5
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile23">
<summary>
 portable-net45+sl4
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile19">
<summary>
 portable-net403+sl5
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile18">
<summary>
 portable-net403+sl4
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile14">
<summary>
 portable-net40+sl5
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile7">
<summary>
 portable-net45+win8
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile6">
<summary>
 portable-net403+win8
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile5">
<summary>
 portable-net40+win8
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile4">
<summary>
 portable-net45+sl4+win8+wp7
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile3">
<summary>
 portable-net40+sl4
</summary>
</member>
<member name="T:Paket.PortableProfileType.Profile2">
<summary>
 portable-net40+sl4+win8+wp7
</summary>
</member>
<member name="T:Paket.FrameworkIdentifier">
<summary>
 Framework Identifier type.
</summary>
</member>
<member name="T:Paket.DotNetUnityVersion">
<summary>
 The Framework version.
</summary>
</member>
<member name="T:Paket.DotNetCoreAppVersion">
<summary>
 The .NET Standard version.
</summary>
</member>
<member name="T:Paket.UAPVersion">
<summary>
 The UAP version.
</summary>
</member>
<member name="T:Paket.FrameworkVersion">
<summary>
 The Framework version.
</summary>
</member>
<member name="T:Paket.DotNetStandardVersion">
<summary>
 The .NET Standard version.
</summary>
</member>
<member name="T:Paket.CredentialProviderUnknownStatusException">
<summary>
 Exception for request errors
</summary>
</member>
<member name="T:Paket.InstallOptions">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.Nuspec.Load(System.String)">
<summary>
 load the file from a given file.
</summary>
</member>
<member name="M:Paket.Nuspec.Load(System.String,System.String)">
<summary>
 load the file from an xml text. The fileName is only used for error reporting.
</summary>
</member>
<member name="M:Paket.Nuspec.Load(System.String,System.IO.Stream)">
<summary>
 load the file from an nuspec text stream. The fileName is only used for error reporting.
</summary>
</member>
<member name="M:Paket.Nuspec.Load(System.String,System.Xml.XmlDocument)">
<summary>
 load the file from an XmlDocument. The fileName is only used for error reporting.
</summary>
</member>
<member name="T:Paket.FrameworkAssemblyReference">
<summary>
 Framework assembly reference inside of nuspec files.
</summary>
</member>
<member name="T:Paket.NuspecReferences">
<summary>
  Nuspec reference type inside of nuspec files.
</summary>
</member>
<member name="T:Paket.RuntimeGraph">
<summary>
 The runtime graph consolidating compatibility informations across the different RIDs
</summary>
</member>
<member name="T:Paket.RuntimeDescription">
<summary>
 The description for a particular RID, indicates inherited (compatible) RIDs and runtime dependencies for this RID.
</summary>
</member>
<member name="T:Paket.CompatibilityProfile">
<summary>
 A compatibility profile identifies which RIDs are compatible with what FrameworkIdentifier (TargetFrameworkMoniker/tfm in NuGet world)
</summary>
</member>
<member name="T:Paket.Rid">
<summary>
 The runtime identifiert for a specific runtime. Should be treated as a black box in combination with the operations defined on the RuntimeGraph
</summary>
</member>
<member name="T:Paket.InstallModel">
<summary>
 Represents the contents of a particular package at a particular version.  Any install-specific actions like Content files, References, Roslyn Analyzers, MsBuild targets are represented here.
</summary>
</member>
<member name="P:Paket.PackageLoadScript.Path">
<summary>
 Path of the load script
</summary>
</member>
<member name="P:Paket.AnalyzerLib.Language">
<summary>
 Target language for the analyzer
</summary>
</member>
<member name="P:Paket.AnalyzerLib.Path">
<summary>
 Path of the analyzer dll
</summary>
</member>
<member name="T:Paket.FrameworkFolder`1">
<summary>
 Represents a subfolder of a nuget package that provides files (content, references, etc) for one or more Target Profiles.  This is a logical representation of the &apos;net45&apos; folder in a NuGet package, for example.
</summary>
</member>
<member name="P:Paket.Library.Name">
<summary>
 Usually the file name without extension, use for sorting and stuff.
</summary>
</member>
<member name="T:Paket.SolutionFile">
<summary>
 Contains methods to read and manipulate solution files.
</summary>
</member>
<member name="P:Paket.LockFile.InstalledPackages">
<summary>
 Returns a list of packages inside the lockfile with their group and version number
</summary>
</member>
<member name="M:Paket.LockFile.Save">
<summary>
 Updates the paket.lock file with the analyzed dependencies from the paket.dependencies file.
</summary>
</member>
<member name="M:Paket.LockFile.Parse(System.String,System.String[])">
<summary>
 Parses a paket.lock file from lines
</summary>
</member>
<member name="M:Paket.LockFile.LoadFrom(System.String)">
<summary>
 Parses a paket.lock file from file
</summary>
</member>
<member name="M:Paket.LockFile.GetDirectDependenciesOfSafe(Paket.Domain.GroupName,Paket.Domain.PackageName,System.String)">
<summary>
 Gets only direct dependencies of the given package in the given group.
</summary>
</member>
<member name="M:Paket.LockFile.GetAllNormalizedDependenciesOf(Paket.Domain.GroupName,Paket.Domain.PackageName,System.String)">
<summary>
 Gets all dependencies of the given package
</summary>
</member>
<member name="M:Paket.LockFile.GetAllDependenciesOfSafe(Paket.Domain.GroupName,Paket.Domain.PackageName)">
<summary>
 Gets all dependencies of the given package in the given group.
</summary>
</member>
<member name="M:Paket.LockFile.GetAllDependenciesOf(Paket.Domain.GroupName,Paket.Domain.PackageName,System.String)">
<summary>
 Gets all dependencies of the given package
</summary>
</member>
<member name="T:Paket.LockFile">
<summary>
 Allows to parse and analyze paket.lock files.
</summary>
</member>
<member name="P:Paket.OptionalPackagingInfo.Files">
<summary>
 (src * target) list
</summary>
</member>
<member name="M:Paket.ProjectFile.FindAllProjects(System.String)">
<summary>
 Finds all project files
</summary>
</member>
<member name="M:Paket.ProjectFile.FindAllProjectFiles(System.String)">
<summary>
 Finds all project files
</summary>
</member>
<member name="T:Paket.ProjectFile">
<summary>
 Contains methods to read and manipulate project files.
</summary>
</member>
<member name="T:Paket.ProjectOutputType">
<summary>
 Project output type.
</summary>
</member>
<member name="T:Paket.CompileItem">
<summary>
 Compile items inside of project files.
</summary>
</member>
<member name="T:Paket.ProjectReference">
<summary>
 Project references inside of project files.
</summary>
</member>
<member name="T:Paket.FileItem">
<summary>
 File item inside of project files.
</summary>
</member>
<member name="P:Paket.DependenciesFile.DirectoryInfo">
<summary>
 Directory info for the parent of this paket.dependencies file
</summary>
</member>
<member name="P:Paket.DependenciesFile.Directory">
<summary>
 The full path of the directory that containes this paket.dependencies file
</summary>
</member>
<member name="M:Paket.DependenciesFile.GetDependenciesInGroup(Paket.Domain.GroupName)">
<summary>
 Returns all direct NuGet dependencies in the given group.
</summary>
</member>
<member name="M:Paket.DependenciesFile.FindLockfile(System.String)">
<summary>
 Find the matching lock file to a dependencies file
</summary>
</member>
<member name="M:Paket.DependenciesFile.FindLockFile">
<summary>
 Find the matching lock file to a dependencies file
</summary>
</member>
<member name="T:Paket.DependenciesFile">
<summary>
 Allows to parse and analyze paket.dependencies files.
</summary>
</member>
<member name="T:Paket.ReferenceType.LoadScript">
<summary>
 Relative path based on base-directory
</summary>
</member>
<member name="T:Paket.InstallerOptions">
<summary>
 Force             - Force the download and reinstallation of all packages
 Redirects         - Create binding redirects for the NuGet packages
 OnlyReferenced    - Only install packages that are referenced in paket.references files.
 TouchAffectedRefs - Touch projects referencing installed packages even if the project file does not change.
</summary>
</member>
<member name="P:Paket.Dependencies.RootPath">
<summary>
 Get the root path
</summary>
</member>
<member name="P:Paket.Dependencies.RootDirectory">
<summary>
 Get the root directory
</summary>
</member>
<member name="P:Paket.Dependencies.DependenciesFile">
<summary>
 Get path to dependencies file
</summary>
</member>
<member name="M:Paket.Dependencies.UpdatePackage(Microsoft.FSharp.Core.FSharpOption{System.String},System.String,Microsoft.FSharp.Core.FSharpOption{System.String},System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,Paket.SemVerUpdateMode,System.Boolean)">
<summary>
 Updates the given package.
</summary>
</member>
<member name="M:Paket.Dependencies.UpdatePackage(Microsoft.FSharp.Core.FSharpOption{System.String},System.String,Microsoft.FSharp.Core.FSharpOption{System.String},System.Boolean,Paket.SemVerUpdateMode,System.Boolean)">
<summary>
 Updates the given package.
</summary>
</member>
<member name="M:Paket.Dependencies.UpdateGroup(System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,Paket.SemVerUpdateMode,System.Boolean)">
<summary>
 Updates dependencies in single group.
</summary>
</member>
<member name="M:Paket.Dependencies.UpdateFilteredPackages(Microsoft.FSharp.Core.FSharpOption{System.String},System.String,Microsoft.FSharp.Core.FSharpOption{System.String},System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,Paket.SemVerUpdateMode,System.Boolean)">
<summary>
 Update a filtered set of packages
</summary>
</member>
<member name="M:Paket.Dependencies.Update(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,Paket.SemVerUpdateMode,System.Boolean)">
<summary>
 Updates all dependencies.
</summary>
</member>
<member name="M:Paket.Dependencies.Update(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
<summary>
 Updates all dependencies.
</summary>
</member>
<member name="M:Paket.Dependencies.Update(System.Boolean)">
<summary>
 Updates all dependencies.
</summary>
</member>
<member name="M:Paket.Dependencies.TurnOnAutoRestore">
<summary>
 Pulls new paket.targets and bootstrapper and puts them into .paket folder.
</summary>
</member>
<member name="M:Paket.Dependencies.TurnOffAutoRestore">
<summary>
 Removes paket.targets file and Import section from project files.
</summary>
</member>
<member name="M:Paket.Dependencies.TryLocate(System.String)">
<summary>
 Tries to locate the paket.dependencies file in the given folder or a parent folder.
</summary>
</member>
<member name="M:Paket.Dependencies.TryLocate">
<summary>
 Tries to locate the paket.dependencies file in the current folder or a parent folder.
</summary>
</member>
<member name="M:Paket.Dependencies.Simplify(System.Boolean)">
<summary>
 Converts the current package dependency graph to the simplest dependency graph.
</summary>
</member>
<member name="M:Paket.Dependencies.SimplePackagesRestore">
<summary>
 Simple packages restore: 
 - Doesn&apos;t restore projects
 - Doesn&apos;t write targets file
</summary>
</member>
<member name="M:Paket.Dependencies.ShowReferencesFor(Microsoft.FSharp.Collections.FSharpList{System.Tuple{System.String,System.String}})">
<summary>
 Shows all references files where the given package is referenced.
</summary>
</member>
<member name="M:Paket.Dependencies.ShowOutdated(System.Boolean,System.Boolean,Microsoft.FSharp.Core.FSharpOption{System.String})">
<summary>
 Lists outdated packages.
</summary>
</member>
<member name="M:Paket.Dependencies.Restore(System.Boolean,Microsoft.FSharp.Core.FSharpOption{System.String},System.Boolean,System.Boolean,System.Boolean,System.Boolean,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String})">
<summary>
 Restores packages for all available paket.references files
 (or all packages if onlyReferenced is false)
</summary>
</member>
<member name="M:Paket.Dependencies.Restore(System.Boolean,Microsoft.FSharp.Core.FSharpOption{System.String},System.String,System.Boolean,System.Boolean,System.Boolean,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String})">
<summary>
 Restores the given paket.references files.
</summary>
</member>
<member name="M:Paket.Dependencies.Restore(System.Boolean,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Collections.FSharpList{System.String},System.Boolean,System.Boolean,System.Boolean,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String})">
<summary>
 Restores the given paket.references files.
</summary>
</member>
<member name="M:Paket.Dependencies.Restore(Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Restores the given paket.references files.
</summary>
</member>
<member name="M:Paket.Dependencies.Restore(Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Collections.FSharpList{System.String},System.Boolean)">
<summary>
 Restores the given paket.references files.
</summary>
</member>
<member name="M:Paket.Dependencies.Restore">
<summary>
 Restores all dependencies.
</summary>
</member>
<member name="M:Paket.Dependencies.Restore(System.Boolean)">
<summary>
 Restores all dependencies.
</summary>
</member>
<member name="M:Paket.Dependencies.RemoveFromProject(Microsoft.FSharp.Core.FSharpOption{System.String},System.String,System.Boolean,System.String,System.Boolean)">
<summary>
 Removes the given package from the specified project
</summary>
</member>
<member name="M:Paket.Dependencies.Remove(Microsoft.FSharp.Core.FSharpOption{System.String},System.String,System.Boolean,System.Boolean,System.Boolean)">
<summary>
 Removes the given package from dependencies file.
</summary>
</member>
<member name="M:Paket.Dependencies.Remove(Microsoft.FSharp.Core.FSharpOption{System.String},System.String)">
<summary>
 Removes the given package from dependencies file.
</summary>
</member>
<member name="M:Paket.Dependencies.Remove(System.String)">
<summary>
 Removes the given package from the main dependency group of the dependencies file.
</summary>
</member>
<member name="M:Paket.Dependencies.Push``1(System.String,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{System.Int32})">
<summary>
 Pushes a nupkg file.
</summary>
</member>
<member name="M:Paket.Dependencies.Process``1(Microsoft.FSharp.Core.FSharpFunc{Paket.PaketEnv,Chessie.ErrorHandling.Result{``0,Paket.Domain.DomainMessage}})">
<summary>
 Binds the given processing ROP function to current environment and executes it.
 Throws on failure.
</summary>
</member>
<member name="M:Paket.Dependencies.Locate(System.String)">
<summary>
 Tries to locate the paket.dependencies file in the given folder or a parent folder, throws an exception if unsuccessful.
</summary>
</member>
<member name="M:Paket.Dependencies.Locate">
<summary>
 Tries to locate the paket.dependencies file in the current folder or a parent folder, throws an exception if unsuccessful.
</summary>
</member>
<member name="M:Paket.Dependencies.ListTemplateFiles">
<summary>
 Lists all paket.template files in the current solution.
</summary>
</member>
<member name="M:Paket.Dependencies.Install(System.String,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Paket.SemVerUpdateMode},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.String}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpList{System.String}})">
<summary>
 Creates a paket.dependencies file with the given text in the current directory and installs it.
</summary>
</member>
<member name="M:Paket.Dependencies.Install(Paket.InstallerOptions)">
<summary>
 Installs all dependencies.
</summary>
</member>
<member name="M:Paket.Dependencies.Install(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,Paket.SemVerUpdateMode,System.Boolean,System.Boolean,Microsoft.FSharp.Collections.FSharpList{System.String},Microsoft.FSharp.Collections.FSharpList{System.String},Microsoft.FSharp.Core.FSharpOption{System.String})">
<summary>
 Installs all dependencies.
</summary>
</member>
<member name="M:Paket.Dependencies.Install(System.Boolean)">
<summary>
 Installs all dependencies.
</summary>
</member>
<member name="M:Paket.Dependencies.Init(System.String,Microsoft.FSharp.Collections.FSharpList{Paket.PackageSources.PackageSource},Microsoft.FSharp.Collections.FSharpList{System.String},System.Boolean)">
<summary>
 Initialize paket.dependencies file in the given directory
</summary>
</member>
<member name="M:Paket.Dependencies.Init(System.String)">
<summary>
 Initialize paket.dependencies file in the given directory
</summary>
</member>
<member name="M:Paket.Dependencies.Init">
<summary>
 Initialize paket.dependencies file in current directory
</summary>
</member>
<member name="M:Paket.Dependencies.GetSources">
<summary>
 Returns all sources from the dependencies file.
</summary>
</member>
<member name="M:Paket.Dependencies.GetLockFile">
<summary>
 Returns an instance of the paket.lock file.
</summary>
</member>
<member name="M:Paket.Dependencies.GetLibraries(Microsoft.FSharp.Core.FSharpOption{System.String},System.String,Paket.TargetProfile)">
<summary>
 Returns all libraries for the given package and framework.
</summary>
</member>
<member name="M:Paket.Dependencies.GetInstalledVersion(Microsoft.FSharp.Core.FSharpOption{System.String},System.String)">
<summary>
 Returns the installed version of the given package.
</summary>
</member>
<member name="M:Paket.Dependencies.GetInstalledVersion(System.String)">
<summary>
 Returns the installed version of the given package.
</summary>
</member>
<member name="M:Paket.Dependencies.GetInstalledPackages(Paket.ReferencesFile)">
<summary>
 Returns the installed versions of all installed packages which are referenced in the references file.
</summary>
</member>
<member name="M:Paket.Dependencies.GetInstalledPackages">
<summary>
 Returns the installed versions of all installed packages.
</summary>
</member>
<member name="M:Paket.Dependencies.GetInstalledPackageModel(Microsoft.FSharp.Core.FSharpOption{System.String},System.String)">
<summary>
 Returns an InstallModel for the given package.
</summary>
</member>
<member name="M:Paket.Dependencies.GetGroups">
<summary>
 Returns all groups.
</summary>
</member>
<member name="M:Paket.Dependencies.GetDirectDependenciesForPackage(Paket.Domain.GroupName,System.String)">
<summary>
 Returns the direct dependencies for the given package.
</summary>
</member>
<member name="M:Paket.Dependencies.GetDirectDependencies">
<summary>
 Returns the installed versions of all direct dependencies.
</summary>
</member>
<member name="M:Paket.Dependencies.GetDirectDependencies(Paket.ReferencesFile)">
<summary>
 Returns the installed versions of all direct dependencies which are referenced in the references file.
</summary>
</member>
<member name="M:Paket.Dependencies.GetDependenciesFile">
<summary>
 Returns an instance of the paket.dependencies file.
</summary>
</member>
<member name="M:Paket.Dependencies.GetDefinedNuGetFeeds">
<summary>
 Returns all system-wide defined NuGet feeds. (Can be used for Autocompletion)
</summary>
</member>
<member name="M:Paket.Dependencies.FixNuspecs(System.String,Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Fix the transitive references in a list of generated .nuspec files
</summary>
</member>
<member name="M:Paket.Dependencies.FindReferencesFor(System.String,System.String)">
<summary>
 Finds all references files where the given package is referenced.
</summary>
</member>
<member name="M:Paket.Dependencies.FindReferencesFor(System.String)">
<summary>
 Finds all references files where the given main group package is referenced.
</summary>
</member>
<member name="M:Paket.Dependencies.FindProjectsFor(System.String,System.String)">
<summary>
 Finds all projects where the given package is referenced.
</summary>
</member>
<member name="M:Paket.Dependencies.FindOutdated(System.Boolean,System.Boolean,Microsoft.FSharp.Core.FSharpOption{System.String})">
<summary>
 Finds all outdated packages.
</summary>
</member>
<member name="M:Paket.Dependencies.DownloadLatestBootstrapper">
<summary>
 Downloads the latest paket.bootstrapper into the .paket folder and try to rename it to paket.exe in order to activate magic mode.
</summary>
</member>
<member name="M:Paket.Dependencies.ConvertFromNuget(System.Boolean,System.Boolean,System.Boolean,Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.IO.DirectoryInfo})">
<summary>
 Converts the solution from NuGet to Paket.
</summary>
</member>
<member name="M:Paket.Dependencies.ClearCache(Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Clears the NuGet cache
</summary>
</member>
<member name="M:Paket.Dependencies.AddToken(System.String,System.String)">
<summary>
 Adds a token for a source
</summary>
</member>
<member name="M:Paket.Dependencies.AddToProject(Microsoft.FSharp.Core.FSharpOption{System.String},System.String,System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.String,System.Boolean,Paket.SemVerUpdateMode,System.Boolean,System.Boolean,Paket.Requirements.PackageRequirementKind)">
<summary>
 Adds the given package with the given version to the dependencies file.
</summary>
</member>
<member name="M:Paket.Dependencies.AddToProject(Microsoft.FSharp.Core.FSharpOption{System.String},System.String,System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.String,System.Boolean,Paket.SemVerUpdateMode,System.Boolean,System.Boolean)">
<summary>
 Adds the given package with the given version to the dependencies file.
</summary>
</member>
<member name="M:Paket.Dependencies.AddToProject(Microsoft.FSharp.Core.FSharpOption{System.String},System.String,System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.String,System.Boolean,Paket.SemVerUpdateMode,System.Boolean)">
<summary>
 Adds the given package with the given version to the dependencies file.
</summary>
</member>
<member name="M:Paket.Dependencies.AddGithub(Microsoft.FSharp.Core.FSharpOption{System.String},System.String,System.String,System.String,Paket.InstallerOptions)">
<summary>
 Adds the given github repository to the dependencies file.
</summary>
</member>
<member name="M:Paket.Dependencies.AddGithub(Microsoft.FSharp.Core.FSharpOption{System.String},System.String,System.String,System.String)">
<summary>
 Adds the given github repository to the dependencies file.
</summary>
</member>
<member name="M:Paket.Dependencies.AddGithub(Microsoft.FSharp.Core.FSharpOption{System.String},System.String,System.String)">
<summary>
 Adds the given github repository to the dependencies file.
</summary>
</member>
<member name="M:Paket.Dependencies.AddGit(Microsoft.FSharp.Core.FSharpOption{System.String},System.String,System.String,Paket.InstallerOptions)">
<summary>
 Adds the given git repository to the dependencies file
</summary>
</member>
<member name="M:Paket.Dependencies.AddGit(Microsoft.FSharp.Core.FSharpOption{System.String},System.String,System.String)">
<summary>
 Adds the given git repository to the dependencies file    
</summary>
</member>
<member name="M:Paket.Dependencies.AddGit(Microsoft.FSharp.Core.FSharpOption{System.String},System.String)">
<summary>
 Adds the given git repository to the dependencies file
</summary>
</member>
<member name="M:Paket.Dependencies.AddCredentials(System.String,System.String,System.String,System.String,System.Boolean)">
<summary>
 Adds credentials for a Nuget feed
</summary>
</member>
<member name="M:Paket.Dependencies.AddCredentials(System.String,System.String,System.String,System.String)">
<summary>
 Adds credentials for a Nuget feed
</summary>
</member>
<member name="M:Paket.Dependencies.Add(Microsoft.FSharp.Core.FSharpOption{System.String},System.String,System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,Paket.SemVerUpdateMode,System.Boolean,System.Boolean,Paket.Requirements.PackageRequirementKind)">
<summary>
 Adds the given package with the given version to the dependencies file.
</summary>
</member>
<member name="M:Paket.Dependencies.Add(Microsoft.FSharp.Core.FSharpOption{System.String},System.String,System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,Paket.SemVerUpdateMode,System.Boolean,System.Boolean)">
<summary>
 Adds the given package with the given version to the dependencies file.
</summary>
</member>
<member name="M:Paket.Dependencies.Add(Microsoft.FSharp.Core.FSharpOption{System.String},System.String,System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,Paket.SemVerUpdateMode,System.Boolean)">
<summary>
 Adds the given package with the given version to the dependencies file.
</summary>
</member>
<member name="M:Paket.Dependencies.Add(Microsoft.FSharp.Core.FSharpOption{System.String},System.String,System.String)">
<summary>
 Adds the given package with the given version to the dependencies file.
</summary>
</member>
<member name="M:Paket.Dependencies.Add(System.String)">
<summary>
 Adds the given package without version requirements to main dependency group of the dependencies file.
</summary>
</member>
<member name="M:Paket.Dependencies.Add(Microsoft.FSharp.Core.FSharpOption{System.String},System.String)">
<summary>
 Adds the given package without version requirements to the dependencies file.
</summary>
</member>
<member name="T:Paket.Dependencies">
<summary>
 Paket API which is optimized for F# Interactive use.
</summary>
</member>
<member name="T:Paket.Domain.GroupName">
<summary>
 Represents a normalized group name
</summary>
</member>
<member name="T:Paket.Domain.PackageName">
<summary>
 Represents a NuGet package name
</summary>
</member>
<member name="M:Paket.Domain.GroupName(System.String)">
<summary>
 Function to convert a string into a group name
</summary>
</member>
<member name="M:Paket.Domain.PackageName(System.String)">
<summary>
 Function to convert a string into a NuGet package name
</summary>
</member>
<member name="P:Paket.Constants.NuGetCacheFolder">
<summary>
 The NuGet cache folder.
</summary>
</member>
<member name="P:Paket.Constants.MagicUnlistingDate">
<summary>
 The magic unpublished date is 1900-01-01T00:00:00
</summary>
</member>
<member name="P:Paket.Constants.PaketFolderName">
<summary>
 &apos;.paket&apos;
</summary>
</member>
<member name="P:Paket.Constants.DependenciesFileName">
<summary>
 &apos;paket.dependencies&apos;
</summary>
</member>
<member name="P:Paket.Constants.RestoreHashFile">
<summary>
 &apos;paket.restore.sha512&apos;
</summary>
</member>
<member name="P:Paket.Constants.LocalFileName">
<summary>
 &apos;paket.local&apos;
</summary>
</member>
<member name="P:Paket.Constants.LockFileName">
<summary>
 &apos;paket.lock&apos;
</summary>
</member>
<member name="T:Paket.Utils.ResolvedPackagesFolder.SymbolicLink">
<summary>
 the /packages/group/ExtractedPackage.X.Y.Z folder
</summary>
</member>
<member name="T:Paket.Utils.ResolvedPackagesFolder.NoPackagesFolder">
<summary>
 No &quot;packages&quot; folder for the current package
</summary>
</member>
<member name="M:Paket.Utils.FindAllFiles(System.String,System.String)">
<summary>
 Gets all files with the given pattern
</summary>
</member>
<member name="M:Paket.Utils.askYesNo(System.String)">
<summary>
 If the guard is true then a [Y]es / [N]o question will be ask.
 Until the user pressed y or n.
</summary>
</member>
<member name="M:Paket.Utils.normalizeXml(System.Xml.XmlDocument)">
<summary>
 [omit]
</summary>
</member>
<member name="P:Paket.Utils.isMono">
<summary>
 Determines if the current system is a mono system
 Todo: Detect mono on windows
</summary>
</member>
<member name="P:Paket.Utils.isWindows">
<summary>
 Determines if the current system is a Windows system
</summary>
</member>
<member name="P:Paket.Utils.isLinux">
<summary>
 Determines if the current system is a Linux system
</summary>
</member>
<member name="P:Paket.Utils.isMacOS">
<summary>
 Determines if the current system is a MacOs system
</summary>
</member>
<member name="P:Paket.Utils.isUnix">
<summary>
 Determines if the current system is an Unix system
</summary>
</member>
<member name="P:Paket.Utils.SystemRoot">
<summary>
 The system root environment variable. Typically &quot;C:\Windows&quot;
</summary>
</member>
<member name="P:Paket.Utils.ProgramFilesX86">
<summary>
 The path of Program Files (x86)
 It seems this covers all cases where PROCESSOR\_ARCHITECTURE may misreport and the case where the other variable
 PROCESSOR\_ARCHITEW6432 can be null
</summary>
</member>
<member name="P:Paket.Utils.ProgramFiles">
<summary>
 The path of the &quot;Program Files&quot; folder - might be x64 on x64 machine
</summary>
</member>
<member name="M:Paket.Utils.createRelativePath(System.String,System.String)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.Utils.CleanDir(System.String)">
<summary>
 Cleans a directory by deleting it and recreating it.
</summary>
</member>
<member name="M:Paket.Utils.createDir(System.String)">
<summary>
 Creates a directory if it does not exist.
</summary>
</member>
<member name="M:Paket.Utils.quote(System.String)">
<summary>
 Adds quotes around the string
 [omit]
</summary>
</member>
<member name="M:Paket.Utils.Seq.partitionAndChoose``3(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``2}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Unzip a seq by mapping the elements that satisfy the predicate
 into the first seq and mapping the elements that fail to satisfy the predicate
 into the second seq
</summary>
</member>
<member name="M:Paket.Utils.ObservableExtensions.Observable.guard``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit},System.IObservable{``0})">
<summary>
 Creates an observable that calls the specified function after someone
 subscribes to it (useful for waiting using &apos;let!&apos; when we need to start
 operation after &apos;let!&apos; attaches handler)
</summary>
</member>
<member name="M:Paket.Utils.String.|EndsWithIC|_|(System.String,System.String)">
<summary>
 Match if &apos;text&apos; ends with the &apos;suffix&apos; string case insensitive
</summary>
</member>
<member name="M:Paket.Utils.String.endsWithIgnoreCase(System.String,System.String)">
<summary>
 Check if &apos;text&apos; ends with the &apos;suffix&apos; string case insensitive
</summary>
</member>
<member name="M:Paket.Utils.String.|StartsWithIC|_|(System.String,System.String)">
<summary>
 Match if &apos;text&apos; starts with the &apos;prefix&apos; string case insensitive
</summary>
</member>
<member name="M:Paket.Utils.String.startsWithIgnoreCase(System.String,System.String)">
<summary>
 Check if &apos;text&apos; starts with the &apos;prefix&apos; string case insensitive
</summary>
</member>
<member name="M:Paket.Utils.String.|ContainsIC|_|(System.String,System.String)">
<summary>
 Match if &apos;text&apos; includes the &apos;target&apos; string case insensitive
</summary>
</member>
<member name="M:Paket.Utils.String.containsIgnoreCase(System.String,System.String)">
<summary>
 Check if &apos;text&apos; includes the &apos;target&apos; string case insensitive
</summary>
</member>
<member name="M:Paket.Utils.String.|EqualsIC|_|(System.String,System.String)">
<summary>
 Match if the strings are equal ignoring case
</summary>
</member>
<member name="M:Paket.Utils.String.equalsIgnoreCase(System.String,System.String)">
<summary>
 Check if the two strings are equal ignoring case
</summary>
</member>
<member name="M:Paket.Utils.String.|RemovePrefix|_|(System.String,System.String)">
<summary>
 Match if &apos;text&apos; starts with the &apos;prefix&apos; and return the text with the prefix removed
</summary>
</member>
<member name="M:Paket.Utils.String.|StartsWith|_|(System.String,System.String)">
<summary>
 Match if &apos;text&apos; starts with the &apos;prefix&apos; string case
</summary>
</member>
<member name="T:Paket.Utils">
<summary>
 Contains methods for IO.
</summary>
</member>
<member name="M:Paket.Xml.getChildNodes(System.Xml.XmlNode)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.Xml.getDescendants(System.String,System.Xml.XmlNode)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.Xml.getNodes(System.String,System.Xml.XmlNode)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.Xml.optGetNode``1(System.String,Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.Xml.getNode(System.String,System.Xml.XmlNode)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.Xml.optGetAttribute``1(System.String,Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.Xml.withAttributeValueEndsWith(System.String,System.String,System.Xml.XmlNode)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.Xml.withAttributeValue(System.String,System.String,System.Xml.XmlNode)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.Xml.getAttribute(System.String,System.Xml.XmlNode)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.Xml.hasAttribute(System.String,System.Xml.XmlNode)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.Xml.addChild(System.Xml.XmlNode,System.Xml.XmlElement)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.Xml.addAttribute(System.String,System.String,System.Xml.XmlElement)">
<summary>
 [omit]
</summary>
</member>
<member name="T:Paket.ProcessHelper.ProcessResult">
<summary>
 A process result including error code, message log and errors.
</summary>
</member>
<member name="M:Paket.ProcessHelper.directExec(Microsoft.FSharp.Core.FSharpFunc{System.Diagnostics.ProcessStartInfo,Microsoft.FSharp.Core.Unit})">
<summary>
 Runs the given process, waits for its completion and returns if it succeeded.
</summary>
</member>
<member name="M:Paket.ProcessHelper.fireAndForget(Microsoft.FSharp.Core.FSharpFunc{System.Diagnostics.ProcessStartInfo,Microsoft.FSharp.Core.Unit})">
<summary>
 Starts the given process and returns immediatly.
</summary>
</member>
<member name="M:Paket.ProcessHelper.toLines(System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Converts a sequence of strings into a string separated with line ends
</summary>
</member>
<member name="M:Paket.ProcessHelper.separated(System.String,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Converts a sequence of strings to a string with delimiters
</summary>
</member>
<member name="M:Paket.ProcessHelper.ExecProcessAndReturnMessages(Microsoft.FSharp.Core.FSharpFunc{System.Diagnostics.ProcessStartInfo,Microsoft.FSharp.Core.Unit},System.TimeSpan)">
<summary>
 Runs the given process and returns the process result.
 ## Parameters

  - `configProcessStartInfoF` - A function which overwrites the default ProcessStartInfo.
  - `timeOut` - The timeout for the process.
</summary>
</member>
<member name="M:Paket.ProcessHelper.ExecProcessWithLambdas(Microsoft.FSharp.Core.FSharpFunc{System.Diagnostics.ProcessStartInfo,Microsoft.FSharp.Core.Unit},System.TimeSpan,System.Boolean,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.Unit})">
<summary>
 Runs the given process and returns the exit code.
 ## Parameters

  - `configProcessStartInfoF` - A function which overwrites the default ProcessStartInfo.
  - `timeOut` - The timeout for the process.
  - `silent` - If this flag is set then the process output is redirected to the given output functions `errorF` and `messageF`.
  - `errorF` - A function which will be called with the error log.
  - `messageF` - A function which will be called with the message log.
</summary>
</member>
<member name="M:Paket.ProcessHelper.start(System.Diagnostics.Process)">
<summary>
 [omit]
</summary>
</member>
<member name="P:Paket.ProcessHelper.startedProcesses">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.ProcessHelper.findPath(System.String,System.String,System.String)">
<summary>
 Tries to find the tool via AppSettings. If no path has the right tool we are trying the PATH system variable.
 [omit]
</summary>
</member>
<member name="M:Paket.ProcessHelper.tryFindPath(System.String,System.String,System.String)">
<summary>
 Tries to find the tool via AppSettings. If no path has the right tool we are trying the PATH system variable.
 [omit]
</summary>
</member>
<member name="M:Paket.ProcessHelper.appSettings(System.String,System.String)">
<summary>
 Returns the AppSettings for the key - Splitted on ;
 [omit]
</summary>
</member>
<member name="M:Paket.ProcessHelper.platformInfoAction(System.Diagnostics.ProcessStartInfo)">
<summary>
 Modifies the ProcessStartInfo according to the platform semantics
</summary>
</member>
<member name="M:Paket.ProcessHelper.tryFindFileOnPath(System.String)">
<summary>
 Searches the current directory and the directories within the PATH
 environment variable for the given file. If successful returns the full
 path to the file.
 ## Parameters
  - `file` - The file to locate
</summary>
</member>
<member name="P:Paket.ProcessHelper.pathDirectories">
<summary>
 Gets the list of valid directories included in the PATH environment variable.
</summary>
</member>
<member name="M:Paket.ProcessHelper.isValidPath(System.String)">
<summary>
 Detects whether the given path does not contains invalid characters.
</summary>
</member>
<member name="M:Paket.ProcessHelper.splitEnvironVar(System.String)">
<summary>
 Splits the entries of an environment variable and removes the empty ones.
</summary>
</member>
<member name="M:Paket.ProcessHelper.environVarOrNone(System.String)">
<summary>
 Retrieves the environment variable or None
</summary>
</member>
<member name="M:Paket.ProcessHelper.findFile(System.Collections.Generic.IEnumerable{System.String},System.String)">
<summary>
 Searches the given directories for the given file, failing if not found.
 [omit]
</summary>
</member>
<member name="M:Paket.ProcessHelper.tryFindFile(System.Collections.Generic.IEnumerable{System.String},System.String)">
<summary>
 Searches the given directories for all occurrences of the given file name
 [omit]
</summary>
</member>
<member name="P:Paket.ProcessHelper.monoArguments">
<summary>
 Arguments on the Mono executable
</summary>
</member>
<member name="T:Paket.NetUtils.RequestFailedException">
<summary>
 Exception for request errors
</summary>
</member>
<member name="T:Paket.NetUtils.AuthProvider">
<summary>
 Credentials Provider, the paramter indicates whether we need to retry, because some previous request failed
</summary>
</member>
<member name="T:Paket.NetUtils.AuthType">
<summary>
SecurityProtocolType.Tls ||| SecurityProtocolType.Tls11 ||| SecurityProtocolType.Tls12 ||| SecurityProtocolType.Ssl3
</summary>
</member>
<member name="M:Paket.NetUtils.safeGetFromUrl(Paket.NetUtils.AuthProvider,System.String,System.String)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.NetUtils.getFromUrl(Paket.NetUtils.AuthProvider,System.String,System.String)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.NetUtils.downloadFromUrl(Paket.NetUtils.AuthProvider,System.String,System.String)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.NetUtils.downloadFromUrlWithTimeout(Paket.NetUtils.AuthProvider,System.String,Microsoft.FSharp.Core.FSharpOption{System.TimeSpan},System.String)">
<summary>
 [omit]
</summary>
</member>
<member name="T:Paket.NetUtils">
<summary>
 Contains methods for Network IO.
</summary>
</member>
<member name="P:Paket.SemVer.Parse">
<summary>
 Parses the given version string into a SemVerInfo which can be printed using ToString() or compared
 according to the rules described in the [SemVer docs](http://semver.org/).
 ## Sample

     parse &quot;1.0.0-rc.1&quot;     &lt; parse &quot;1.0.0&quot;          // true
     parse &quot;1.2.3-alpha&quot;    &gt; parse &quot;1.2.2&quot;          // true
     parse &quot;1.2.3-alpha2&quot;   &gt; parse &quot;1.2.3-alpha&quot;    // true
     parse &quot;1.2.3-alpha002&quot; &gt; parse &quot;1.2.3-alpha1&quot;   // true
     parse &quot;1.5.0-beta.2&quot;   &gt; parse &quot;1.5.0-rc.1&quot;     // false
</summary>
</member>
<member name="M:Paket.SemVer.expand(Microsoft.FSharp.Collections.FSharpList{System.Char},System.String)">
<summary>
 Splits the given version string by possible delimiters but keeps them as parts of resulting list.
</summary>
</member>
<member name="M:Paket.SemVer.|Big|_|(System.String)">
<summary>
 Matches if str is convertible to big int and not less than zero, and returns the bigint value.
</summary>
</member>
<member name="M:Paket.SemVer.|Int|_|(System.String)">
<summary>
 Matches if str is convertible to Int and not less than zero, and returns the value as UInt.
</summary>
</member>
<member name="T:Paket.SemVer">
<summary>
  Parser which allows to deal with [Semantic Versioning](http://semver.org/) (SemVer).
</summary>
</member>
<member name="M:Paket.SupportCalculation.isSupportedBy(Paket.TargetProfile,Paket.TargetProfile)">
<summary>
 true when x is supported by y, for example netstandard15 is supported by netcore10
</summary>
</member>
<member name="P:Paket.FrameworkDetection.Extract">
<summary>
 parse a string to construct a Netframework, NetCore, NetStandard, or other dotnet identifier
</summary>
</member>
<member name="P:Paket.FrameworkDetection.resolveEnvironmentFramework">
<summary>
 Used for script generation
</summary>
</member>
<member name="M:Paket.ConfigFile.GetAuthenticationProvider(System.String)">
<summary>
 Get the authentication from the authentication store for a specific source
</summary>
</member>
<member name="P:Paket.ConfigFile.GetAuthenticationForUrl">
<summary>
 Get the authentication from the authentication store for a specific source and validates against the url
</summary>
</member>
<member name="M:Paket.ConfigFile.checkCredentials(System.String,Microsoft.FSharp.Core.FSharpOption{Paket.NetUtils.Auth})">
<summary>
 Check if the provided credentials for a specific source are correct
</summary>
</member>
<member name="M:Paket.ConfigFile.Decrypt(System.String,System.String)">
<summary>
 Decrypt a encrypted string with a user specific keys
</summary>
</member>
<member name="M:Paket.ConfigFile.Encrypt(System.String)">
<summary>
 Encrypts a string with a user specific keys
</summary>
</member>
<member name="T:Paket.PackageSources.PackageSource">
<summary>
 Represents the package source type.
</summary>
</member>
<member name="T:Paket.Requirements.PackageRequirement">
<summary>
 Represents an unresolved package.
</summary>
</member>
<member name="P:Paket.Requirements.FrameworkRestrictionP.RepresentedFrameworks">
<summary>
 The list represented by this restriction (ie the included set of frameworks)
</summary>
</member>
<member name="M:Paket.Requirements.FrameworkRestrictionP.IsSubsetOf(Paket.Requirements.FrameworkRestrictionP)">
<summary>
 Returns true if the restriction x is a subset of the restriction y (a restriction basically represents a list, see RepresentedFrameworks)
 For example =net46 is a subset of &gt;=netstandard13
</summary>
</member>
<member name="M:Paket.Requirements.applyRestrictionsToTargets(Paket.Requirements.FrameworkRestriction,Microsoft.FSharp.Collections.FSharpSet{Paket.TargetProfile})">
<summary>
 Get all targets that should be considered with the specified restrictions
</summary>
</member>
<member name="M:Paket.Requirements.isTargetMatchingRestrictions(Paket.Requirements.FrameworkRestriction,Paket.TargetProfile)">
<summary>
 Get if a target should be considered with the specified restrictions
</summary>
</member>
<member name="T:Paket.InterprojectReferencesConstraint.InterprojectReferencesConstraint">
<summary>
 Constraints template for interproject references
</summary>
</member>
<member name="M:Paket.Git.CommandHelper.runSimpleGitCommand(System.String,System.String)">
<summary>
 Runs the git command and returns the first line of the result.
</summary>
</member>
<member name="M:Paket.Git.CommandHelper.runFullGitCommand(System.String,System.String)">
<summary>
 Runs the git command and returns the results.
</summary>
</member>
<member name="M:Paket.Git.CommandHelper.gitCommandf``1(System.String,Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,Microsoft.FSharp.Core.Unit})">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.Git.CommandHelper.gitCommand(System.String,System.String)">
<summary>
 Runs the given git command, waits for its completion.
</summary>
</member>
<member name="M:Paket.Git.CommandHelper.directRunGitCommand(System.String,System.String)">
<summary>
 Runs the given git command, waits for its completion and returns whether it succeeded.
</summary>
</member>
<member name="M:Paket.Git.CommandHelper.fireAndForgetGitCommand(System.String,System.String)">
<summary>
 Fires the given git command ind the given repository directory and returns immediatly.
</summary>
</member>
<member name="M:Paket.Git.CommandHelper.getGitResult(System.String,System.String)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.Git.CommandHelper.runGitCommandf``1(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,Microsoft.FSharp.Core.FSharpFunc{System.String,System.Tuple{System.Boolean,System.Collections.Generic.List{System.String},System.String}}})">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.Git.CommandHelper.runGitCommand(System.String,System.String)">
<summary>
 Runs git.exe with the given command in the given repository directory.
</summary>
</member>
<member name="P:Paket.Git.CommandHelper.gitPath">
<summary>
 Tries to locate the git.exe via the eviroment variable &quot;GIT&quot;.
</summary>
</member>
<member name="P:Paket.Git.CommandHelper.gitTimeOut">
<summary>
 Specifies a global timeout for git.exe - default is *no timeout*
</summary>
</member>
<member name="T:Paket.Git.CommandHelper">
<summary>
 Contains helpers which allow to interact with [git](http://git-scm.com/) via the command line.
</summary>
</member>
<member name="T:Paket.ModuleResolver">
<summary>
 Contains logic which helps to resolve the dependency graph for modules
</summary>
</member>
<member name="M:Paket.RemoteDownload.downloadRemoteFiles(Paket.ModuleResolver.ResolvedSourceFile,System.String)">
<summary>
 Retrieves RemoteFiles
</summary>
</member>
<member name="M:Paket.RemoteDownload.downloadDependenciesFile``1(System.Boolean,System.String,Paket.Domain.GroupName,Microsoft.FSharp.Core.FSharpFunc{System.String,``0},Paket.ModuleResolver.ResolvedSourceFile)">
<summary>
 Gets a dependencies file from the remote source and tries to parse it.
</summary>
</member>
<member name="T:Paket.PackageResolver.VersionCache">
<summary>
 Caches information retrieved by GetVersions until it is required by GetDetails
</summary>
</member>
<member name="T:Paket.PackageResolver.ResolvedPackage">
<summary>
 Represents data about resolved packages
</summary>
</member>
<member name="T:Paket.PackageResolver.PackageDetails">
<summary>
 Represents package details
</summary>
</member>
<member name="M:Paket.PackageResolver.Resolve(Microsoft.FSharp.Core.FSharpFunc{Paket.PackageResolver.GetPackageVersionsParameters,Microsoft.FSharp.Control.FSharpAsync{System.Collections.Generic.IEnumerable{System.Tuple{Paket.SemVerInfo,Microsoft.FSharp.Collections.FSharpList{Paket.PackageSources.PackageSource}}}}},Microsoft.FSharp.Core.FSharpFunc{Paket.ResolverStrategy,Microsoft.FSharp.Core.FSharpFunc{Paket.PackageResolver.GetPackageVersionsParameters,Microsoft.FSharp.Collections.FSharpList{System.Tuple{Paket.SemVerInfo,Microsoft.FSharp.Collections.FSharpList{Paket.PackageSources.PackageSource}}}}},Microsoft.FSharp.Core.FSharpFunc{Paket.PackageResolver.GetPackageDetailsParameters,Microsoft.FSharp.Control.FSharpAsync{Paket.PackageResolver.PackageDetails}},Paket.Domain.GroupName,Microsoft.FSharp.Core.FSharpOption{Paket.ResolverStrategy},Microsoft.FSharp.Core.FSharpOption{Paket.ResolverStrategy},Paket.Requirements.FrameworkRestrictions,Microsoft.FSharp.Collections.FSharpSet{Paket.Requirements.PackageRequirement},Paket.PackageResolver.UpdateMode)">
<summary>
 Resolves all direct and transitive dependencies
</summary>
</member>
<member name="T:Paket.PackageResolver">
<summary>
 Contains logic which helps to resolve the dependency graph.
</summary>
</member>
<member name="M:Paket.NuGetCache.CopyToCache(Paket.Cache,System.String,System.Boolean)">
<summary>
 Puts the package into the cache
</summary>
</member>
<member name="M:Paket.NuGetCache.CopyFromCache(Paket.Utils.ResolvedPackagesFolder,System.String,System.String,Paket.Domain.PackageName,Paket.SemVerInfo,System.Boolean,System.Boolean)">
<summary>
 Extracts the given package to the ./packages folder
</summary>
</member>
<member name="M:Paket.NuGetCache.ExtractPackage(System.String,System.String,Paket.Domain.PackageName,Paket.SemVerInfo,System.Boolean)">
<summary>
 Extracts the given package to the ./packages folder
</summary>
</member>
<member name="M:Paket.NuGetCache.ExtractPackageToUserFolder(System.String,Paket.Domain.PackageName,Paket.SemVerInfo,Paket.PackageResolver.ResolvedPackageKind)">
<summary>
 Extracts the given package to the user folder
</summary>
</member>
<member name="T:Paket.NuGetCache">
<summary>
 Contains NuGet cache support.
</summary>
</member>
<member name="T:Paket.NuGetV3.NugetV3CatalogPageItem">
<summary>
 large unused fields are commented-out
</summary>
</member>
<member name="T:Paket.NuGetV3.JSONRootData">
<summary>
 [omit]
</summary>
</member>
<member name="T:Paket.NuGetV3.JSONVersionData">
<summary>
 [omit]
</summary>
</member>
<member name="T:Paket.NuGetV3.JSONResource">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.NuGetV3.GetPackageDetails(System.Boolean,Paket.PackageSources.NuGetSource,Paket.Domain.PackageName,Paket.SemVerInfo)">
<summary>
 Uses the NuGet v3 registration endpoint to retrieve package details .
</summary>
</member>
<member name="M:Paket.NuGetV3.FindPackages(Paket.NetUtils.AuthProvider,System.String,System.String,System.Int32)">
<summary>
 Uses the NuGet v3 autocomplete service to retrieve all packages with the given prefix.
</summary>
</member>
<member name="M:Paket.NuGetV3.extractPackages(System.String)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.NuGetV3.FindVersionsForPackage(System.String,Paket.NetUtils.AuthProvider,Paket.Domain.PackageName)">
<summary>
 Uses the NuGet v3 service to retrieve all package versions for the given package.
</summary>
</member>
<member name="M:Paket.NuGetV3.FindAutoCompleteVersionsForPackage(System.String,Paket.NetUtils.AuthProvider,Paket.Domain.PackageName,System.Boolean,System.Int32)">
<summary>
 Uses the NuGet v3 autocomplete service to retrieve all package versions for the given package.
</summary>
</member>
<member name="M:Paket.NuGetV3.extractVersions(System.String)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.NuGetV3.extractAutoCompleteVersions(System.String)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.NuGetV3.getCatalogPage(Paket.NetUtils.AuthProvider,Paket.NuGetV3.NugetV3CatalogIndexItem,System.String,System.Threading.CancellationToken)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.NuGetV3.getCatalogIndex(Paket.NetUtils.AuthProvider,System.String,System.Threading.CancellationToken)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.NuGetV3.getCatalogAPI(Paket.NetUtils.AuthProvider,System.String)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.NuGetV3.getAllVersionsAPI(Paket.NetUtils.AuthProvider,System.String)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.NuGetV3.getSearchAPI(Paket.NetUtils.AuthProvider,System.String)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.NuGetV3.calculateNuGet2Path(System.String)">
<summary>
 Calculates the NuGet v3 URL from a NuGet v2 URL.
</summary>
</member>
<member name="M:Paket.NuGetV3.calculateNuGet3Path(System.String)">
<summary>
 Calculates the NuGet v3 URL from a NuGet v2 URL.
</summary>
</member>
<member name="P:Paket.NuGetV3.allVersionsDict">
<summary>
 [omit]
</summary>
</member>
<member name="P:Paket.NuGetV3.searchDict">
<summary>
 [omit]
</summary>
</member>
<member name="T:Paket.NuGetV3">
<summary>
 Contains NuGet support.
</summary>
</member>
<member name="M:Paket.NuGetV2.FindPackages``1(Paket.NetUtils.AuthProvider,System.String,System.String,``0)">
<summary>
 Uses the NuGet v2 API to retrieve all packages with the given prefix.
</summary>
</member>
<member name="M:Paket.NuGetV2.getDetailsFromNuGetViaOData(System.Boolean,Paket.PackageSources.NuGetSource,Paket.Domain.PackageName,Paket.SemVerInfo)">
<summary>
 Gets package details from NuGet via OData
</summary>
</member>
<member name="T:Paket.NuGetV2">
<summary>
 Contains NuGet support.
</summary>
</member>
<member name="M:Paket.NuGetLocal.getDetailsFromLocalNuGetPackage(System.Boolean,Microsoft.FSharp.Core.FSharpOption{System.String},System.String,System.String,Paket.Domain.PackageName,Paket.SemVerInfo)">
<summary>
 Reads direct dependencies from a nupkg file
</summary>
</member>
<member name="M:Paket.NuGetLocal.getPackageNameFromLocalFile(System.String)">
<summary>
 Reads package name from a nupkg file
</summary>
</member>
<member name="M:Paket.NuGetLocal.getNuSpecFromNupgk(System.String)">
<summary>
 Reads nuspec from nupkg
</summary>
</member>
<member name="M:Paket.NuGetLocal.parsePackageInfoFromFileName(System.String)">
<summary>
 Reads packageName and version from .nupkg file name
</summary>
</member>
<member name="M:Paket.NuGetLocal.getAllVersionsFromLocalPath(System.Boolean,System.String,Paket.Domain.PackageName,Microsoft.FSharp.Core.FSharpOption{System.String},System.String)">
<summary>
 Gets versions of the given package from local NuGet feed.
</summary>
</member>
<member name="M:Paket.NuGet.downloadAndExtractPackage(Microsoft.FSharp.Core.FSharpOption{System.String},System.String,System.Boolean,Paket.Utils.PackagesFolderGroupConfig,Paket.PackageSources.PackageSource,Microsoft.FSharp.Collections.FSharpList{Paket.Cache},Paket.Domain.GroupName,Paket.Domain.PackageName,Paket.SemVerInfo,Paket.PackageResolver.ResolvedPackageKind,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
<summary>
 Downloads the given package to the NuGet Cache folder
</summary>
</member>
<member name="M:Paket.NuGet.GetVersions(System.Boolean,Microsoft.FSharp.Core.FSharpOption{System.String},System.String,Paket.PackageResolver.GetPackageVersionsParameters)">
<summary>
 Allows to retrieve all version no. for a package from the given sources.
</summary>
</member>
<member name="M:Paket.NuGet.GetAnalyzerFiles(System.String)">
<summary>
 Finds all analyzer files in a nuget package.
</summary>
</member>
<member name="M:Paket.NuGet.GetTargetsFiles(System.String,Paket.Domain.PackageName)">
<summary>
 Finds all targets files in a nuget package.
</summary>
</member>
<member name="M:Paket.NuGet.GetLibFiles(System.String)">
<summary>
 Finds all libraries in a nuget package.
</summary>
</member>
<member name="M:Paket.RuntimeGraphModule.getRuntimeGraphFromNugetCache(System.String,Microsoft.FSharp.Core.FSharpOption{Paket.Utils.PackagesFolderGroupConfig},Paket.Domain.GroupName,Paket.PackageResolver.ResolvedPackage)">
<summary>
 Downloads the given package into the nuget cache and read its runtime.json.
</summary>
</member>
<member name="M:Paket.RuntimeGraphModule.findRuntimeDependencies(Paket.Rid,Paket.Domain.PackageName,Paket.RuntimeGraph)">
<summary>
 return runtime depenendencies for the given package and runtime
</summary>
</member>
<member name="M:Paket.RuntimeGraphModule.areCompatible(Paket.Rid,Paket.Rid,Paket.RuntimeGraph)">
<summary>
 calculates whether the given assetRid is compatible with the given projectRid.
 consider a project targeting projectRid, this returns true if an asset with assetRid is comaptible.
</summary>
</member>
<member name="M:Paket.RuntimeGraphModule.getKnownRids(Paket.RuntimeGraph)">
<summary>
 get a list of RIDs in no particular order which are part of this runtime graph
</summary>
</member>
<member name="M:Paket.RuntimeGraphModule.getInheritanceList(Paket.Rid,Paket.RuntimeGraph)">
<summary>
 get the list of compatible RIDs for the given RID. Most compatible are near the head. The list contains the given RID in the HEAD
</summary>
</member>
<member name="M:Paket.RuntimeGraphModule.mergeSeq(System.Collections.Generic.IEnumerable{Paket.RuntimeGraph})">
<summary>
 merge a sequence of runtime graphs
</summary>
</member>
<member name="M:Paket.RuntimeGraphModule.merge(Paket.RuntimeGraph,Paket.RuntimeGraph)">
<summary>
 merge two runtime graphs
</summary>
</member>
<member name="T:Paket.RuntimeGraphParser">
<summary>
 A module for parsing runtime.json files contained in various packages.
</summary>
</member>
<member name="M:Paket.InstallModelModule.getLegacyPlatformReferences(Paket.TargetProfile,Paket.InstallModel)">
<summary>
 This is for library references, which at the same time can be used for references (old world - pre dotnetcore)
</summary>
</member>
<member name="M:Paket.InstallModelModule.getCompileReferences(Paket.TargetProfile,Paket.InstallModel)">
<summary>
 This is for reference assemblies (new dotnetcore world)
</summary>
</member>
<member name="M:Paket.InstallModelModule.getLegacyReferences(Paket.TargetProfile,Paket.InstallModel)">
<summary>
 This is for library references, which at the same time can be used for references (old world - pre dotnetcore)
</summary>
</member>
<member name="M:Paket.LockFileSerializer.serializePackages(Paket.InstallOptions,Microsoft.FSharp.Collections.FSharpMap{Paket.Domain.PackageName,Paket.PackageResolver.ResolvedPackage})">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.LockFileSerializer.serializeOptionsAsLines(Paket.InstallOptions)">
<summary>
 [omit]
</summary>
</member>
<member name="M:Paket.ProjectFileModule.appendMap``2(Microsoft.FSharp.Collections.FSharpMap{``0,``1},Microsoft.FSharp.Collections.FSharpMap{``0,``1})">
<summary>
 Append two maps with the properties of the second replacing properties of the first
</summary>
</member>
<member name="M:Paket.LanguageEvaluation.getProjectLanguage(System.Xml.XmlDocument,System.String)">
<summary>
 Get the programming language for a project file using the &quot;ProjectTypeGuids&quot;
</summary>
</member>
<member name="T:Paket.DependenciesFileSerializer">
<summary>
 [omit]
</summary>
</member>
<member name="T:Paket.BindingRedirects.BindingRedirect">
<summary>
 Represents a binding redirection
</summary>
</member>
<member name="M:Paket.BindingRedirects.getPublicKeyToken(System.Reflection.AssemblyName)">
<summary>
 Calculates the short form of the public key token for use with binding redirects, if it exists.
</summary>
</member>
<member name="M:Paket.BindingRedirects.applyBindingRedirectsToFolder``1(System.Boolean,System.Boolean,System.Boolean,System.String,System.Collections.Generic.IEnumerable{System.String},Microsoft.FSharp.Core.FSharpFunc{Paket.ProjectFile,``0})">
<summary>
 Applies a set of binding redirects to all .config files in a specific folder.
</summary>
</member>
<member name="M:Paket.BindingRedirects.applyBindingRedirects(System.Boolean,System.Boolean,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{Paket.BindingRedirects.BindingRedirect},Paket.ProjectFile,System.String)">
<summary>
 Applies a set of binding redirects to a single configuration file.
</summary>
</member>
<member name="M:Paket.BindingRedirects.setRedirect(System.Xml.Linq.XDocument,Paket.BindingRedirects.BindingRedirect)">
<summary>
 Updates the supplied MSBuild document with the supplied binding redirect.
</summary>
</member>
<member name="T:Paket.DependencyChangeDetection.DependencyChangeType.PackageNotFoundInDependenciesFile">
<summary>
 Package from lock file was not found in dependencies file
</summary>
</member>
<member name="T:Paket.DependencyChangeDetection.DependencyChangeType.GroupNotFoundInLockFile">
<summary>
 Group from dependencies file was not found in lockfile
</summary>
</member>
<member name="T:Paket.DependencyChangeDetection.DependencyChangeType.PackageNotFoundInLockFile">
<summary>
 Package from dependencies file was not found in lockfile
</summary>
</member>
<member name="T:Paket.DependencyChangeDetection.DependencyChangeType.VersionNotValid">
<summary>
 The Version in the LockFile doesn&apos;t match the spec in the dependencies file.
</summary>
</member>
<member name="T:Paket.DependencyChangeDetection.DependencyChangeType.SettingsChanged">
<summary>
 The settings of the package changed
</summary>
</member>
<member name="T:Paket.DependencyChangeDetection.DependencyChangeType.RestrictionsChanged">
<summary>
 The restrictions changed
</summary>
</member>
<member name="M:Paket.LoadingScripts.ScriptGeneration.ScriptContent.Save(System.IO.DirectoryInfo)">
<summary>
 Save the script in &apos;&lt;rootPath&gt;/.paket/load/&lt;script&gt;&apos;
</summary>
</member>
<member name="M:Paket.LoadingScripts.ScriptGeneration.ScriptContent.Render(System.IO.DirectoryInfo)">
<summary>
 use the provided directory to compute the relative paths for the script&apos;s contents
 and construct the 
</summary>
</member>
<member name="M:Paket.LoadingScripts.ScriptGeneration.generateScriptContent(Paket.LoadingScripts.ScriptGeneration.PaketContext)">
<summary>
 Generate a include scripts for all packages defined in paket.dependencies,
 if a package is ordered before its dependencies this function will throw.
</summary>
</member>
<member name="M:Paket.LoadingScripts.ScriptGeneration.generateScript(Paket.LoadingScripts.ScriptGeneration.ScriptType,Paket.LoadingScripts.ScriptGeneration.ScriptGenInput)">
<summary>
 default implementation of F# include script generator
</summary>
</member>
<member name="M:Paket.GarbageCollection.CleanUp(Paket.DependenciesFile,Paket.LockFile)">
<summary>
 Remove all packages from the packages folder which are not part of the lock file.
</summary>
</member>
<member name="M:Paket.GarbageCollection.removeOlderVersionsFromCache(Paket.Cache,Paket.Domain.PackageName,System.Collections.Generic.IEnumerable{Paket.SemVerInfo})">
<summary>
 Removes older packages from the cache
</summary>
</member>
<member name="M:Paket.GarbageCollection.deleteUnusedPackages(Paket.LockFile)">
<summary>
 Remove all packages from the packages folder which are not part of the lock file.
</summary>
</member>
<member name="M:Paket.GarbageCollection.discoverDirectExtractedPackages(Paket.Domain.GroupName,System.IO.DirectoryInfo)">
<summary>
 Discover all packages currently available in the packages folder
</summary>
</member>
<member name="T:Paket.GarbageCollection">
<summary>
 Contains methods for the garbage collection of no longer needed files.
</summary>
</member>
<member name="M:Paket.RestoreProcess.restore(Microsoft.FSharp.Core.FSharpOption{System.String},System.String,Paket.Domain.GroupName,Microsoft.FSharp.Collections.FSharpList{Paket.PackageSources.PackageSource},Microsoft.FSharp.Collections.FSharpList{Paket.Cache},System.Boolean,Paket.LockFile,Microsoft.FSharp.Collections.FSharpSet{Paket.Domain.PackageName},Microsoft.FSharp.Collections.FSharpSet{Paket.Domain.PackageName})">
<summary>
 Restores the given dependencies from the lock file.
</summary>
</member>
<member name="M:Paket.RestoreProcess.ExtractPackage(Microsoft.FSharp.Core.FSharpOption{System.String},System.String,Paket.Domain.GroupName,Microsoft.FSharp.Collections.FSharpList{Paket.PackageSources.PackageSource},Microsoft.FSharp.Collections.FSharpList{Paket.Cache},System.Boolean,Paket.PackageResolver.PackageInfo,System.Boolean)">
<summary>
 Downloads and extracts a package.
 returns - package, libs files, props files, targets files, analyzers files
</summary>
</member>
<member name="M:Paket.RestoreProcess.extractPackage(Microsoft.FSharp.Collections.FSharpList{Paket.Cache},Paket.PackageResolver.PackageInfo,Microsoft.FSharp.Core.FSharpOption{System.String},System.String,System.Boolean,Paket.PackageSources.PackageSource,Paket.Domain.GroupName,Paket.SemVerInfo,System.Boolean,System.Boolean,System.Boolean)">
<summary>
 returns - package, libs files, props files, targets files, analyzers files
</summary>
</member>
<member name="M:Paket.RestoreProcess.FindPackagesNotExtractedYet(System.String)">
<summary>
 Finds packages which would be affected by a restore, i.e. not extracted yet or with the wrong version
</summary>
</member>
<member name="M:Paket.RestoreProcess.CombineCopyLocal(Paket.Requirements.InstallSettings,Paket.PackageInstallSettings)">
<summary>
 Combines the copy_local settings from the lock file and a project&apos;s references file
</summary>
</member>
<member name="T:Paket.RestoreProcess">
<summary>
 Contains methods for the restore process.
</summary>
</member>
<member name="M:Paket.InstallProcess.Install``1(Paket.InstallerOptions,System.Boolean,Paket.DependenciesFile,Paket.LockFile,Microsoft.FSharp.Collections.FSharpMap{Paket.Domain.GroupName,``0})">
<summary>
 Installs all packages from the lock file.
</summary>
</member>
<member name="M:Paket.InstallProcess.InstallIntoProjects``1(Paket.InstallerOptions,System.Boolean,Paket.DependenciesFile,Paket.LockFile,Microsoft.FSharp.Collections.FSharpList{System.Tuple{Paket.ProjectFile,Paket.ReferencesFile}},Microsoft.FSharp.Collections.FSharpMap{Paket.Domain.GroupName,``0})">
<summary>
 Installs all packages from the lock file.
</summary>
</member>
<member name="M:Paket.InstallProcess.applyBindingRedirects``1(System.Boolean,System.Boolean,System.Boolean,System.String,Paket.Domain.GroupName,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{Paket.Domain.GroupName,Paket.Domain.PackageName,System.String},``0},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.Dictionary{System.String,Microsoft.FSharp.Core.FSharpOption{Paket.ProjectFile}},System.Collections.Generic.IEnumerable{System.Tuple{Paket.InstallModel,Microsoft.FSharp.Core.FSharpOption{Paket.Requirements.BindingRedirectsSettings}}})">
<summary>
 Applies binding redirects for all strong-named references to all app. and web.config files.
</summary>
</member>
<member name="M:Paket.InstallProcess.CreateModel``1(Microsoft.FSharp.Core.FSharpOption{System.String},System.String,System.Boolean,Paket.DependenciesFile,Paket.LockFile,Microsoft.FSharp.Collections.FSharpSet{System.Tuple{Paket.Domain.GroupName,Paket.Domain.PackageName}},Microsoft.FSharp.Collections.FSharpMap{Paket.Domain.GroupName,``0})">
<summary>
 Restores the given packages from the lock file.
</summary>
</member>
<member name="T:Paket.InstallProcess">
<summary>
 Contains methods for the install process.
</summary>
</member>
<member name="M:Paket.UpdateProcess.Update(System.String,Paket.UpdaterOptions)">
<summary>
 Update command
</summary>
</member>
<member name="M:Paket.UpdateProcess.UpdateGroup(System.String,Paket.Domain.GroupName,Paket.UpdaterOptions)">
<summary>
 Update a single group command
</summary>
</member>
<member name="M:Paket.UpdateProcess.UpdateFilteredPackages(System.String,Paket.Domain.GroupName,System.String,Microsoft.FSharp.Core.FSharpOption{System.String},Paket.UpdaterOptions)">
<summary>
 Update a filtered list of packages
</summary>
</member>
<member name="M:Paket.UpdateProcess.UpdatePackage(System.String,Paket.Domain.GroupName,Paket.Domain.PackageName,Microsoft.FSharp.Core.FSharpOption{System.String},Paket.UpdaterOptions)">
<summary>
 Update a single package command
</summary>
</member>
<member name="M:Paket.UpdateProcess.SmartInstall(Paket.DependenciesFile,Paket.PackageResolver.UpdateMode,Paket.UpdaterOptions)">
<summary>
 Smart install command
</summary>
</member>
<member name="T:Paket.UpdateProcess">
<summary>
 Contains methods for the update process.
</summary>
</member>
<member name="M:Paket.FindOutdated.ShowOutdated(System.Boolean,System.Boolean,System.Boolean,Microsoft.FSharp.Core.FSharpOption{System.String},Paket.PaketEnv)">
<summary>
 Prints all outdated packages.
</summary>
</member>
<member name="M:Paket.FindOutdated.FindOutdated(System.Boolean,System.Boolean,System.Boolean,Microsoft.FSharp.Core.FSharpOption{System.String},Paket.PaketEnv)">
<summary>
 Finds all outdated packages.
</summary>
</member>
<member name="T:Paket.FindOutdated">
<summary>
 Contains methods to find outdated packages.
</summary>
</member>
<member name="M:Paket.DependencyModel.CalcDependencies(Paket.DependenciesFile,Paket.Domain.GroupName,System.String)">
<summary>
 Calculates the used dependencies for a project.
</summary>
</member>
<member name="M:Paket.DependencyModel.CalcDependenciesForReferencesFile(Paket.DependenciesFile,Paket.Domain.GroupName,System.String)">
<summary>
 Calculates the used dependencies for given references file.
</summary>
</member>
<member name="M:Paket.DependencyModel.CalcDependenciesForDirectPackages(Paket.DependenciesFile,Paket.Domain.GroupName,Microsoft.FSharp.Collections.FSharpList{Paket.Domain.PackageName})">
<summary>
 Calculates the used dependencies for the given direct references.
</summary>
</member>
<member name="M:Paket.Releases.downloadLatestTargets(Paket.PaketEnv)">
<summary>
 Downloads the latest version of the paket.bootstrapper and paket.targets to the .paket dir
</summary>
</member>
<member name="M:Paket.Releases.downloadLatestBootstrapperAndTargets(Paket.PaketEnv)">
<summary>
 Downloads the latest version of the paket.bootstrapper and paket.targets to the .paket dir
</summary>
</member>
<member name="M:Paket.Releases.downloadLatestVersionOf(Microsoft.FSharp.Collections.FSharpList{System.String},System.String)">
<summary>
 Downloads the latest version of the given files to the destination dir
</summary>
</member>
<member name="M:Paket.VSIntegration.TurnOnAutoRestore(Paket.PaketEnv)">
<summary>
 Activates the Visual Studio NuGet autorestore feature in all projects
</summary>
</member>
<member name="M:Paket.VSIntegration.TurnOffAutoRestore(Paket.PaketEnv)">
<summary>
 Deactivates the Visual Studio NuGet autorestore feature in all projects
</summary>
</member>
<member name="T:Paket.AddProcess">
<summary>
 Contains methods for addition of new packages
</summary>
</member>
<member name="T:Paket.NuGetConvert.NugetPackagesConfig">
<summary>
 Represents NuGet packages.config file
</summary>
</member>
<member name="T:Paket.NuGetConvert.NugetPackagesConfigType">
<summary>
 Represents type of NuGet packages.config file
</summary>
</member>
<member name="T:Paket.NuGetConvert">
<summary>
 Contains methods for NuGet conversion
</summary>
</member>
<member name="M:Paket.RemoveProcess.Remove(System.String,Microsoft.FSharp.Core.FSharpOption{System.String},Paket.Domain.PackageName,System.Boolean,System.Boolean,System.Boolean)">
<summary>
 Remove a package with the option to interactively remove it from multiple projects.
</summary>
</member>
<member name="M:Paket.RemoveProcess.RemoveFromProject(System.String,Microsoft.FSharp.Core.FSharpOption{System.String},Paket.Domain.PackageName,System.Boolean,System.String,System.Boolean)">
<summary>
 Removes a package with the option to remove it from a specified project.
</summary>
</member>
<member name="T:Paket.RemoveProcess">
<summary>
 Contains methods to remove installed packages
</summary>
</member>
<member name="M:Paket.PublicAPI.ParseSemVer(System.String)">
<summary>
 Takes a version string formatted for Semantic Versioning and parses it
 into the internal representation used by Paket.
</summary>
</member>
</members>
</doc>
