<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FParsec</name></assembly>
<members>
<member name="M:FParsec.InternalsModule.LineWrapper.Break(System.String)">
<summary>
 breaks a string into multiple lines along text element boundaries.
</summary>
</member>
<member name="T:FParsec.InternalsModule.LineWrapper">
<summary>
 A primitive pretty printer.
</summary>
</member>
<member name="M:FParsec.Error.ParserError.WriteTo(System.IO.TextWriter,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{System.IO.TextWriter,Microsoft.FSharp.Core.FSharpFunc{FParsec.Position,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.Unit}}}}},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String})">
<summary>
 Writes a string representation of the `ParserError` to the given `TextWriter` value.

 The format of the position information can be customized by specifying the `positionPrinter`
 argument. The given function is expected to print a representation of the passed `Position` value
 to the passed `TextWriter` value. If possible, it should indent text lines with the passed string
 and take into account the maximum column count (including indention) passed as the last argument.
</summary>
</member>
<member name="M:FParsec.Error.ParserError.WriteTo``1(System.IO.TextWriter,Microsoft.FSharp.Core.FSharpFunc{FParsec.Position,FParsec.CharStream{``0}},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String})">
<summary>
 Writes a string representation of the `ParserError` to the given `TextWriter` value.

 For each error position `getStreamByName` is called with the `StreamName` of the `Position`.
 The returned `CharStream` must be `null` or contain the content of the `CharStream` for which
 the error was generated (at the original indices).

 If `getStreamByName` returns a non-null `CharStream`, the printed error position information is
 augmented with the line of text surrounding the error position, together with a &apos;^&apos;-marker
 pointing to the exact location of the error in the input stream.
</summary>
</member>
<member name="M:FParsec.Error.ParserError.WriteTo``1(System.IO.TextWriter,FParsec.CharStream{``0},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.Int32},Microsoft.FSharp.Core.FSharpOption{System.String},Microsoft.FSharp.Core.FSharpOption{System.String})">
<summary>
 Writes a string representation of the `ParserError` to the given `TextWriter` value.

 The given `CharStream` must contain the content of the original `CharStream`
 for which this `ParserError` was generated (at the original indices).

 For each error location the printed position information is augmented
 with the line of text surrounding the error position, together with a &apos;^&apos;-marker
 pointing to the exact location of the error in the input stream.
</summary>
</member>
<member name="M:FParsec.Error.ParserError.ToString``1(FParsec.CharStream{``0})">
<summary>
 Returns a string representation of the `ParserError`.

 The given `CharStream` must contain the content of the original `CharStream`
 for which this `ParserError` was generated (at the original indices).

 For each error location the printed position information is augmented
 with the line of text surrounding the error position, together with a &apos;^&apos;-marker
 pointing to the exact location of the error in the input stream.
</summary>
</member>
<member name="M:FParsec.Error.ParserError.ToString">
<summary>
 Returns a string representation of the `ParserError`.
</summary>
</member>
<member name="T:FParsec.Error.ParserError">
<summary>
 Represents a simple container type that brings together the position, user state and error messages of a parser error.
</summary>
</member>
<member name="M:FParsec.Error.mergeErrors(FParsec.ErrorMessageList,FParsec.ErrorMessageList)">
<summary>
 `mergeErrors error1 error2` is equivalent to `ErrorMessageList.Merge(error1, error2)`.
</summary>
</member>
<member name="M:FParsec.Error.compoundError``1(System.String,FParsec.CharStream{``0},FParsec.ErrorMessageList)">
<summary>
 `compoundError label state msgs` creates an `ErrorMessageList` with a single `CompoundError label stream.Position msgs` message,
 except if `msgs` is an `ErrorMessageList` with a single `BacktrackPoint(pos2, msgs2)` message,
 in which case an `ErrorMessageList` with a single `CompoundError label pos2 msgs2` message is returned instead.
</summary>
</member>
<member name="M:FParsec.Error.nestedError``1(FParsec.CharStream{``0},FParsec.ErrorMessageList)">
<summary>
 `backtrackError stream msgs` creates an `ErrorMessageList` with a single `BacktrackPoint stream.Position msgs` message,
 except if `msgs` is already an `ErrorMessageList` with a single `BacktrackPoint(_, _)` message,
 in which case `msgs` is returned instead.
</summary>
</member>
<member name="M:FParsec.Error.otherError(System.Object)">
<summary>
 `otherError o` creates an `ErrorMessageList` with a single `OtherError o` message.
</summary>
</member>
<member name="M:FParsec.Error.messageError(System.String)">
<summary>
 `messageError msg` creates an `ErrorMessageList` with a single `Message msg` message.
</summary>
</member>
<member name="M:FParsec.Error.unexpectedStringCI(System.String)">
<summary>
 `unexpectedStringCIError str` creates an `ErrorMessageList` with a single `UnexpectedStringCI str` message.
</summary>
</member>
<member name="M:FParsec.Error.unexpectedString(System.String)">
<summary>
 `unexpectedStringError str` creates an `ErrorMessageList` with a single `UnexpectedString str` message.
</summary>
</member>
<member name="M:FParsec.Error.unexpected(System.String)">
<summary>
 `unexpectedError label` creates an `ErrorMessageList` with a single `Unexpected label` message.
</summary>
</member>
<member name="M:FParsec.Error.expectedStringCI(System.String)">
<summary>
 `expectedStringCIError str` creates an `ErrorMessageList` with a single `ExpectedStringCI str` message.
</summary>
</member>
<member name="M:FParsec.Error.expectedString(System.String)">
<summary>
 `expectedStringError str` creates an `ErrorMessageList` with a single `ExpectedString str` message.
</summary>
</member>
<member name="M:FParsec.Error.expected(System.String)">
<summary>
 `expectedError label` creates an `ErrorMessageList` with a single `Expected label` message.
</summary>
</member>
<member name="T:FParsec.Primitives.ParserCombinator">
<summary>
 The type of the &quot;builder object&quot; that can be used to build parsers with
 F#&apos;s &quot;computation expression&quot; syntax a.k.a. &quot;workflow&quot; syntax.
</summary>
</member>
<member name="T:FParsec.Primitives.Parser`2">
<summary>
 The type of the parser functions supported by FParsec combinators.
</summary>
</member>
<member name="M:FParsec.Primitives.createParserForwardedToRef``2">
<summary>
 `let p, pRef = createParserForwardedToRef()` creates a parser `p` that forwards all
 calls to the parser in the reference cell `pRef`. Initially, `pRef` holds a reference
 to a dummy parser that raises an exception on any invocation.
</summary>
</member>
<member name="P:FParsec.Primitives.parse">
<summary>
 The builder object for building parsers using F#&apos;s computation expression syntax.
</summary>
</member>
<member name="M:FParsec.Primitives.chainr``2(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}}}},``0)">
<summary>
 The parser `chainr p op defVal` is equivalent to `chainr1 p op &lt;|&gt;% defVal`.
</summary>
</member>
<member name="M:FParsec.Primitives.chainr1``2(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}}}})">
<summary>
 The parser `chainr1 p op` parses one or more occurrences of `p` separated by `op`
 (in EBNF notation: `p (op p)*`).
 It returns the value obtained by *right* associative application of all functions
 returned by `op` to the results returned by `p`,
 i.e. `f1 x_1 (f_2 x_2 (... (f_n x_n x_n+1) ...))`,
 where `f_1` to `f_n` are the functions returned by the parser `op` and
 `x_1` to `x_n+1` are the values returned by `p`. If only a single occurance
 of `p` and no occurance of `op` is parsed, the result of `p` is returned directly.
</summary>
</member>
<member name="M:FParsec.Primitives.chainl``2(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}}}},``0)">
<summary>
 The parser `chainl p op defVal` is equivalent to `chainl1 p op &lt;|&gt;% defVal`.
</summary>
</member>
<member name="M:FParsec.Primitives.chainl1``2(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}}}})">
<summary>
 The parser `chainl1 p op` parses one or more occurrences of `p` separated by `op`
 (in EBNF notation: `p (op p)*`).
 It returns the value obtained by *left* associative application of all functions
 returned by `op` to the results returned by `p`,
 i.e. `f_n (... (f_2 (f_1 x_1 x_2) x_3) ...) x_n+1`,
 where `f_1` to `f_n` are the functions returned by the parser `op` and
 `x_1` to `x_n+1` are the values returned by `p`. If only a single occurance
 of `p` and no occurance of `op` is parsed, the result of `p` is returned directly.
</summary>
</member>
<member name="M:FParsec.Primitives.many1Till``3(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``2}})">
<summary>
 The parser `many1Till p endp` behaves like `manyTill p endp`, except that it requires `p` to succeed at least one time.
 `many1Till p endp` is an optimized implementation of `pipe2 p (manyTill p endp) (fun hd tl -&gt; hd::tl)`.
</summary>
</member>
<member name="M:FParsec.Primitives.skipManyTill``3(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``2}})">
<summary>
 The parser `skipManyTill p endp` is an optimized implementation of `manyTill p endp |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.Primitives.manyTill``3(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``2}})">
<summary>
 The `parser manyTill p endp` repeatedly applies the parser `p` 
 for as long as `endp` fails (without changing the parser state).
 It returns a list of the results returned by `p`.
</summary>
</member>
<member name="M:FParsec.Primitives.skipSepEndBy1``3(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``2}})">
<summary>
 The parser `skipSepEndBy1 p sep` is an optimized implementation of `sepEndBy1 p sep |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.Primitives.sepEndBy1``3(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``2}})">
<summary>
 The parser `sepEndBy1 p sep` parses *one* or more occurrences of `p` separated and
 optionally ended by `sep` (in EBNF notation: `p (sep p)* sep?`).
 It returns a list of the results returned by `p`.
</summary>
</member>
<member name="M:FParsec.Primitives.skipSepEndBy``3(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``2}})">
<summary>
 The parser `skipSepEndBy p sep` is an optimized implementation of `sepEndBy p sep |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.Primitives.sepEndBy``3(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``2}})">
<summary>
 The parser `sepEndBy p sep` parses *zero* or more occurrences of `p` separated and
 optionally ended by `sep` (in EBNF notation: `(p (sep p)* sep?)?`).
 It returns a list of the results returned by `p`.
</summary>
</member>
<member name="M:FParsec.Primitives.skipSepBy1``3(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``2}})">
<summary>
 The parser `skipSepBy1 p sep` is an optimized implementation of `sepBy1 p sep |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.Primitives.sepBy1``3(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``2}})">
<summary>
 The parser `sepBy1 p sep` parses *one* or more occurrences of `p` separated by `sep`
 (in EBNF notation: `p (sep p)*`).
</summary>
</member>
<member name="M:FParsec.Primitives.skipSepBy``3(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``2}})">
<summary>
 The parser `skipSepBy p sep` is an optimized implementation of `sepBy p sep |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.Primitives.sepBy``3(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``2}})">
<summary>
 The parser `sepBy p sep` parses *zero* or more occurrences of `p` separated by `sep`
 (in EBNF notation: `(p (sep p)*)?`).
</summary>
</member>
<member name="M:FParsec.Primitives.skipMany1``2(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}})">
<summary>
 The parser `skipMany1 p` is an optimized implementation of `many1 p |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.Primitives.many1``2(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}})">
<summary>
 The parser `many1 p` behaves like `many p`, except that it requires `p` to succeed at least one time.
 `many1 p` is an optimized implementation of `pipe2 p (many p) (fun hd tl -&gt; hd::tl)`.
</summary>
</member>
<member name="M:FParsec.Primitives.skipMany``2(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}})">
<summary>
 The parser `skipMany p` is an optimized implementation of `many p |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.Primitives.many``2(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}})">
<summary>
 The parser `many p` repeatedly applies the parser `p` until `p` fails.
 It returns a list of the results returned by `p`.
 At the end of the sequence `p` must fail without changing the parser state and without
 signalling a `FatalError`, otherwise `many p` will fail with the error reported by `p`.
 `many p` tries to guard against an infinite loop by throwing an exception
 if `p` succeeds without changing the parser state.
</summary>
</member>
<member name="M:FParsec.Primitives.skipArray``2(System.Int32,Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}})">
<summary>
 The parser `skipArray n p` is an optimized implementation of `parray n p |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.Primitives.parray``2(System.Int32,Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}})">
<summary>
 The parser `parray n p` parses `n` occurences of `p` and
 returns the returns the results in an array.
 For example, `parray 3 p` is equivalent to `pipe3 p p p (fun a b c -&gt; [|a;b;c|])`.
</summary>
</member>
<member name="M:FParsec.Primitives.tuple5``6(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``2}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``3}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``4}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``5}})">
<summary>
 The parser `tuple5 p1 p2 p3 p4 p5` applies the parsers `p1`, `p2`, `p3`, `p4` and `p5` in sequence and
 returns the results in a tuple.
</summary>
</member>
<member name="M:FParsec.Primitives.tuple4``5(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``2}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``3}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``4}})">
<summary>
 The parser `tuple4 p1 p2 p3 p4` applies the parsers `p1`, `p2`, `p3` and `p4` in sequence and
 returns the results in a tuple.
</summary>
</member>
<member name="M:FParsec.Primitives.tuple3``4(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``2}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``3}})">
<summary>
 The parser `tuple3 p1 p2 p3` applies the parsers `p1`, `p2` and `p3` in sequence and
 returns the results in a tuple.
</summary>
</member>
<member name="M:FParsec.Primitives.tuple2``3(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``2}})">
<summary>
 The parser `tuple2 p1 p2` applies the parsers `p1` and `p2` in sequence and
 returns the results in a tuple.
 `tuple2 p1 p2` is defined as `p1 .&gt;&gt;. p2`.
</summary>
</member>
<member name="M:FParsec.Primitives.failFatally``2(System.String)">
<summary>
 The parser `failFatally msg` always fails with a `messageError msg`. It signals a
 FatalError, so that no error recovery is attempted (except via backtracking constructs).
</summary>
</member>
<member name="M:FParsec.Primitives.fail``2(System.String)">
<summary>
 The parser `fail msg` always fails with a `messageError msg`.
 The error message will be displayed together with other error messages generated for
 the same input position.
</summary>
</member>
<member name="M:FParsec.Primitives.op_LessQmarkQmarkGreater``2(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},System.String)">
<summary>
 The parser `p &lt;??&gt; label` behaves like `p &lt;?&gt; label`, except that when `p` fails
 after changing the parser state (for example, because `p` consumes input before it fails),
 a `CompoundError` message is generated with both the given string `label` and the
 error messages generated by `p`.
</summary>
</member>
<member name="M:FParsec.Primitives.op_LessQmarkGreater``2(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},System.String)">
<summary>
 The parser `p &lt;?&gt; label` applies the parser `p`. If `p` does not change the parser state
 (usually because `p` failed), the error messages are replaced with `expected label`.
</summary>
</member>
<member name="M:FParsec.Primitives.lookAhead``2(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}})">
<summary>
 The parser `lookAhead p` parses `p` and restores the original parse state afterwards.
 In case `p` fails after changing the parser state, the error messages are wrapped in a `NestedError`.
 If it succeeds, any error messages are discarded. Fatal errors are turned into normal errors.
</summary>
</member>
<member name="M:FParsec.Primitives.notFollowedByL``2(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},System.String)">
<summary>
 The parser `notFollowedByL p` behaves like `notFollowedBy p`,
 except that it returns an `Unexpected label` error message when the parser `p` fails.
</summary>
</member>
<member name="M:FParsec.Primitives.notFollowedBy``2(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}})">
<summary>
 The parser `notFollowedBy p` succeeds if the parser `p` fails to parse at the current position.
 Otherwise it fails with a non-fatal error. This parser never changes the parser state.
 If the parser `notFollowedBy p` fails, it returns no descriptive error message.
 Hence it should only be used together with other parsers that take care of a potential error.
 Alternatively, `notFollowedByL p label` can be used to ensure a more descriptive error message.
</summary>
</member>
<member name="M:FParsec.Primitives.followedByL``2(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},System.String)">
<summary>
 The parser `followedByL p` behaves like `followedBy p`,
 except that it returns an `Expected label` error message when the parser `p` fails.
</summary>
</member>
<member name="M:FParsec.Primitives.followedBy``2(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}})">
<summary>
 The parser `followedBy p` succeeds if the parser `p` succeeds at the current position.
 Otherwise it fails with a non-fatal error. This parser never changes the parser state.
 If the parser `followedBy p` fails, it returns no descriptive error message.
 Hence it should only be used together with other parsers that take care of a potential error.
 Alternatively, `followedByL p label` can be used to ensure a more descriptive error message.
</summary>
</member>
<member name="M:FParsec.Primitives.notEmpty``2(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}})">
<summary>
 The parser `notEmpty p` behaves like `p`,
 except that it fails when `p` succeeds without consuming input
 or changing the parser state in any other way.
</summary>
</member>
<member name="M:FParsec.Primitives.op_DotGreaterGreaterDotQmark``3(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``2}})">
<summary>
 The parser `p1 .&gt;&gt;.? p2` behaves like `p1 .&gt;&gt;. p2`, except that it will backtrack
 to the beginning if `p2` fails with a non-fatal error and without changing the parser state,
 even if `p1` has changed the parser state.
</summary>
</member>
<member name="M:FParsec.Primitives.op_DotGreaterGreaterQmark``3(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``2}})">
<summary>
 The parser `p1 .&gt;&gt;? p2` behaves like `p1 .&gt;&gt; p2`, except that it will backtrack
 to the beginning if `p2` fails with a non-fatal error and without changing the parser state,
 even if `p1` has changed the parser state.
</summary>
</member>
<member name="M:FParsec.Primitives.op_GreaterGreaterQmark``3(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``2}})">
<summary>
 The parser `p1 &gt;&gt;? p2` behaves like `p1 &gt;&gt;. p2`, except that it will backtrack
 to the beginning if `p2` fails with a non-fatal error and without changing the parser state,
 even if `p1` has changed the parser state.
</summary>
</member>
<member name="M:FParsec.Primitives.op_GreaterGreaterEqualsQmark``3(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``2}}})">
<summary>
 The parser `p &gt;&gt;=? f` behaves like `p &gt;&gt;= f`, except that it will backtrack to the beginning
 if the parser returned by `f` fails with a non-fatal error and without changing the parser state,
 even if `p` has changed the parser state.
</summary>
</member>
<member name="M:FParsec.Primitives.attempt``2(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}})">
<summary>
 The parser `attempt p` applies the parser `p`.
 If `p` fails after changing the parser state or with a fatal error,
 `attempt p` will backtrack to the original parser state and report a non-fatal error.
</summary>
</member>
<member name="M:FParsec.Primitives.optional``2(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}})">
<summary>
 The parser `optional p` skips over an optional occurrence of `p`.
 `optional p` is an optimized implementation of `(p &gt;&gt;% ()) &lt;|&gt;% ()`.
</summary>
</member>
<member name="M:FParsec.Primitives.opt``2(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}})">
<summary>
 The parser `opt p` parses an optional occurrence of `p` as an option value.
 `opt p` is an optimized implementation of `(p |&gt;&gt; Some) &lt;|&gt;% None`.
</summary>
</member>
<member name="M:FParsec.Primitives.op_LessBarGreaterPercent``2(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},``0)">
<summary>
 The parser `p &lt;|&gt;% x` is an optimized implementation of `p &lt;|&gt; preturn x`.
</summary>
</member>
<member name="M:FParsec.Primitives.choiceL``2(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}}},System.String)">
<summary>
 The parser `choiceL ps label` is an optimized implementation of `choice ps &lt;?&gt; label`.
</summary>
</member>
<member name="M:FParsec.Primitives.choice``2(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}}})">
<summary>
 The parser `choice ps` is an optimized implementation of `p1 &lt;|&gt; p2 &lt;|&gt; ... &lt;|&gt; pn`,
 where `p1` ... `pn` are the parsers in the sequence `ps`.
</summary>
</member>
<member name="M:FParsec.Primitives.op_LessBarGreater``2(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}})">
<summary>
 The parser `p1 &lt;|&gt; p2` first applies the parser `p1`.
 If `p1` succeeds, the result of `p1` is returned.
 If `p1` fails with a non-fatal error and *without changing the parser state*,
 the parser `p2` is applied.
 Note: The stream position is part of the parser state, so if `p1` fails after consuming input,
 `p2` will not be applied.
</summary>
</member>
<member name="M:FParsec.Primitives.pipe5``7(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``2}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``3}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``4}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``5}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``3,Microsoft.FSharp.Core.FSharpFunc{``4,Microsoft.FSharp.Core.FSharpFunc{``5,``6}}}}})">
<summary>
 The parser `pipe5 p1 p2 p3 p4 p5 f` applies the parsers `p1`, `p2`, `p3`, `p4` and `p5` in sequence.
 It returns the result of the function application `f a b c d e`, where `a`, `b`, `c`, `d` and `e` are the results returned by `p1`, `p2`, `p3`, `p4` and `p5`.
</summary>
</member>
<member name="M:FParsec.Primitives.pipe4``6(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``2}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``3}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``4}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``3,Microsoft.FSharp.Core.FSharpFunc{``4,``5}}}})">
<summary>
 The parser `pipe4 p1 p2 p3 p4 f` applies the parsers `p1`, `p2`, `p3` and `p4` in sequence.
 It returns the result `f a b c d`, where `a`, `b`, `c` and `d` are the results returned by `p1`, `p2`, `p3` and `p4`.
</summary>
</member>
<member name="M:FParsec.Primitives.pipe3``5(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``2}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``3}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``3,``4}}})">
<summary>
 The parser `pipe3 p1 p2 p3 f` applies the parsers `p1`, `p2` and `p3` in sequence.
 It returns the result `f a b c`, where `a`, `b` and `c` are the results returned by `p1`, `p2` and `p3`.
</summary>
</member>
<member name="M:FParsec.Primitives.pipe2``4(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``2}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``2,``3}})">
<summary>
 The parser `pipe2 p1 p2 f` applies the parsers `p1` and `p2` in sequence.
 It returns the result `f a b`, where `a` and `b` are the results returned by `p1` and `p2`.
</summary>
</member>
<member name="M:FParsec.Primitives.op_BarGreaterGreater``3(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},Microsoft.FSharp.Core.FSharpFunc{``0,``2})">
<summary>
 The parser `p |&gt;&gt; f` applies the parser `p` and
 returns the result `f x`,  where `x` is the result returned by `p`.
</summary>
</member>
<member name="M:FParsec.Primitives.between``4(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``2}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``3}})">
<summary>
 The parser `between popen pclose p` applies the parsers `pOpen`, `p` and `pEnd` in sequence.
 It returns the result of `p`.
</summary>
</member>
<member name="M:FParsec.Primitives.op_DotGreaterGreaterDot``3(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``2}})">
<summary>
 The parser `p1 .&gt;&gt;. p2` applies the parsers `p1` and `p2` in sequence and returns the results in a tuple.
</summary>
</member>
<member name="M:FParsec.Primitives.op_DotGreaterGreater``3(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``2}})">
<summary>
 The parser `p1 .&gt;&gt; p2` applies the parsers `p1` and `p2` in sequence and returns the result of `p1`.
</summary>
</member>
<member name="M:FParsec.Primitives.op_GreaterGreaterDot``3(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``2}})">
<summary>
 The parser `p1 &gt;&gt;. p2` applies the parsers `p1` and `p2` in sequence and returns the result of `p2`.
</summary>
</member>
<member name="M:FParsec.Primitives.op_GreaterGreaterPercent``3(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},``2)">
<summary>
 The parser `p &gt;&gt;% x` applies the parser `p` and returns the result `x`.
</summary>
</member>
<member name="M:FParsec.Primitives.op_GreaterGreaterEquals``3(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``2}}})">
<summary>
 The parser `p &gt;&gt;= f` first applies the parser `p` to the input, then applies the function `f`
 to the result returned by `p` and finally applies the parser returned by `f` to the input.
</summary>
</member>
<member name="M:FParsec.Primitives.pzero``2">
<summary>
 The parser `pzero` always fails with an empty error message list, i.e. an unspecified error.
 `pzero x` is defined as `fun stream -&gt; Reply(Error, NoErrorMessages)`.
</summary>
</member>
<member name="M:FParsec.Primitives.preturn``2(``0)">
<summary>
 The parser `preturn x` always succeeds with the result `x` (without changing the parser state).
 `preturn x` is defined as `fun stream -&gt; Reply(x)`.
</summary>
</member>
<member name="P:FParsec.Primitives.FatalError">
<summary>
 The parser failed and no error recovery (except after backtracking) should be tried.
</summary>
</member>
<member name="P:FParsec.Primitives.Error">
<summary>
 The parser failed.
</summary>
</member>
<member name="P:FParsec.Primitives.Ok">
<summary>
 The parser succeeded.
</summary>
</member>
<member name="T:FParsec.CharParsers.NumberLiteralResultFlags">
<summary>
 Encodes various bits of information about a parsed number literal.
</summary>
</member>
<member name="P:FParsec.CharParsers.NumberLiteral.SuffixChar4">
<summary>
 Returns the fourth suffix char, or EOS if less than four suffix chars were parsed
</summary>
</member>
<member name="P:FParsec.CharParsers.NumberLiteral.SuffixChar3">
<summary>
 Returns the third suffix char, or EOS if less than three suffix chars were parsed
</summary>
</member>
<member name="P:FParsec.CharParsers.NumberLiteral.SuffixChar2">
<summary>
 Returns the second suffix char, or EOS if less than two suffix chars were parsed.
</summary>
</member>
<member name="P:FParsec.CharParsers.NumberLiteral.SuffixChar1">
<summary>
 Returns the first suffix char, or EOS if no suffix char was parsed.
</summary>
</member>
<member name="P:FParsec.CharParsers.NumberLiteral.String">
<summary>
 The parsed number literal string. Only includes the parsed suffix chars if the
 `NumberLiteralOptions` passed to the `numberLiteral` parser have the `IncludeSuffixCharsInString` flag set.
</summary>
</member>
<member name="P:FParsec.CharParsers.NumberLiteral.Info">
<summary>
 Eencodes various bits of information on the string literal.
</summary>
</member>
<member name="T:FParsec.CharParsers.NumberLiteral">
<summary>
 The return type of the `numberLiteral` parser. An instance contains the parsed
 number literal and various bits of information about it.
 Note that the `String` member contains the string literal without the suffix chars,
 except if the `NumberLiteralOptions` passed to the `numberLiteral` parser have the
 `IncludeSuffixCharsInString` flag set.
 Any parsed suffix chars are always available through the `SuffixChar1` - `4` members.
</summary>
</member>
<member name="T:FParsec.CharParsers.NumberLiteralOptions">
<summary>
 Encodes the various options of the `numberLiteral` parser.
</summary>
</member>
<member name="T:FParsec.CharParsers.ParserResult`2.Failure">
<summary>
 Failure(errorAsString, error, suserState) holds the parser error and the user state returned by a failing parser,
 together with a string representation of the parser error.
</summary>
</member>
<member name="T:FParsec.CharParsers.ParserResult`2.Success">
<summary>
 Success(result, userState, endPos) holds the result and the user state returned by a successful parser,
 together with the position where the parser stopped.
</summary>
</member>
<member name="T:FParsec.CharParsers.ParserResult`2">
<summary>
 Values of this type are returned by the runParser functions (not by `Parser&lt;_,_&gt;` functions).
</summary>
</member>
<member name="M:FParsec.CharParsers.float32OfHexString(System.String)">
<summary>
 Returns the `float32` value represented by the given string in hexadecimal format.
 Raises a `System.FormatException` in case the string representation is invalid.
 Raises a `System.OverflowException` if the (absolute) value is too large to be represented by a `float32`.
</summary>
</member>
<member name="M:FParsec.CharParsers.float32ToHexString(System.Single)">
<summary>
 Returns a hexadecimal string representation of the `float32` argument.
</summary>
</member>
<member name="M:FParsec.CharParsers.floatOfHexString(System.String)">
<summary>
 Returns the `float` value represented by the given string in hexadecimal format.
 Raises a `System.FormatException` in case the string representation is invalid.
 Raises a `System.OverflowException` if the (absolute) value is too large to be represented by a `float`.
</summary>
</member>
<member name="M:FParsec.CharParsers.floatToHexString(System.Double)">
<summary>
 Returns a hexadecimal string representation of the `float` argument.
</summary>
</member>
<member name="M:FParsec.CharParsers.normalizeNewlines(System.String)">
<summary>
 `normalizeNewlines str` returns a version of `str`
 with all occurances of &quot;\r\n&quot; and &quot;\r&quot; replaced by &quot;\n&quot;.
 If the argument is `null`, `null` is returned.
</summary>
</member>
<member name="M:FParsec.CharParsers.foldCase(System.String)">
<summary>
 `foldCase str` returns a case-folded version of `str`
 with all chars mappend using the (non-Turkic) Unicode 1-to-1 case folding mappings
 for chars below 0x10000. If the argument is `null`, `null` is returned.
</summary>
</member>
<member name="P:FParsec.CharParsers.EOS">
<summary>
 `EOS` is equal to `CharStream&lt;&apos;u&gt;.EndOfStreamChar`.
</summary>
</member>
<member name="M:FParsec.CharParsers.previousCharSatisfiesNot``1(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean})">
<summary>
 `previousCharSatisfies f` succeeds if the predicate function `f` returns `false`
 when applied to the previous char in the stream, otherwise it fails.
 If there is no previous char (because the stream is at the beginning),
 this parser succeeds (as opposed to `previousCharSatisfies`).
 This parser never changes the parser state.
 Any newline (&quot;\n&quot;, &quot;\r\n&quot; or &quot;\r&quot;) in the input is interpreted as a single char &apos;\n&apos;.
 If this parser fails, it returns no descriptive error message; hence it should only be
 used together with parsers that take care of a potential error.
</summary>
</member>
<member name="M:FParsec.CharParsers.previousCharSatisfies``1(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean})">
<summary>
 `previousCharSatisfies f` succeeds if the predicate function `f` returns `true`
 when applied to the previous char in the stream, otherwise it fails.
 If there is no previous char (because the stream is at the beginning),
 this parser fails (as opposed to `previousCharSatisfiesNot`).
 This parser never changes the parser state.
 Any newline (&quot;\n&quot;, &quot;\r\n&quot; or &quot;\r&quot;) in the input is interpreted as a single char &apos;\n&apos;.
 If this parser fails, it returns no descriptive error message; hence it should only be
 used together with parsers that take care of a potential error.
</summary>
</member>
<member name="M:FParsec.CharParsers.next2CharsSatisfyNot``1(Microsoft.FSharp.Core.FSharpFunc{System.Char,Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean}})">
<summary>
 `next2CharsSatisfyNot f` succeeds if the predicate function `f` returns `false`
 when applied to the next 2 chars in the input stream, otherwise it fails.
 If there aren&apos;t 2 chars remaining in the input stream, this parser succeeds (as opposed to `next2CharsSatisfy`).
 This parser never changes the parser state.
 Any newline (&quot;\n&quot;, &quot;\r\n&quot; or &quot;\r&quot;) in the input is interpreted as a single char &apos;\n&apos;.
 If this parser fails, it returns no descriptive error message; hence it should only be
 used together with parsers that take care of a potential error.
</summary>
</member>
<member name="M:FParsec.CharParsers.next2CharsSatisfy``1(Microsoft.FSharp.Core.FSharpFunc{System.Char,Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean}})">
<summary>
 `next2CharsSatisfy f` succeeds if the predicate function `f` returns `true`
 when applied to the next 2 chars in the input stream, otherwise it fails.
 If there aren&apos;t 2 chars remaining in the input stream, this parser fails (as opposed to `next2CharsSatisfyNot`).
 This parser never changes the parser state.
 Any newline (&quot;\n&quot;, &quot;\r\n&quot; or &quot;\r&quot;) in the input is interpreted as a single char &apos;\n&apos;.
 If this parser fails, it returns no descriptive error message; hence it should only be
 used together with parsers that take care of a potential error.
</summary>
</member>
<member name="M:FParsec.CharParsers.nextCharSatisfiesNot``1(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean})">
<summary>
 `nextCharSatisfiesNot f` is an optimized implementation of `notFollowedBy (satisfy f)`.
</summary>
</member>
<member name="M:FParsec.CharParsers.nextCharSatisfies``1(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean})">
<summary>
 `nextCharSatisfies f` is an optimized implementation of `followedBy (satisfy f)`.
</summary>
</member>
<member name="M:FParsec.CharParsers.notFollowedByStringCI``1(System.String)">
<summary>
 `notFollowedByStringCI str` is an optimized implementation of `notFollowedByL (pstringCI str) (&quot;&apos;&quot; + str + &quot;&apos;&quot;)`.
</summary>
</member>
<member name="M:FParsec.CharParsers.notFollowedByString``1(System.String)">
<summary>
 `notFollowedByString str` is an optimized implementation of `notFollowedByL (pstring str) (&quot;&apos;&quot; + str + &quot;&apos;&quot;)`.
</summary>
</member>
<member name="M:FParsec.CharParsers.followedByStringCI``1(System.String)">
<summary>
 `followedByStringCI str` is an optimized implementation of `followedByL (pstringCI str) (&quot;&apos;&quot; + str + &quot;&apos;&quot;)`.
</summary>
</member>
<member name="M:FParsec.CharParsers.followedByString``1(System.String)">
<summary>
 `followedByString str` is an optimized implementation of `followedByL (pstring str) (&quot;&apos;&quot; + str + &quot;&apos;&quot;)`.
</summary>
</member>
<member name="M:FParsec.CharParsers.notFollowedByNewline``1">
<summary>
 `notFollowedByNewline` is an optimized implementation of `notFollowedByL newline &quot;newline&quot;`.
</summary>
</member>
<member name="M:FParsec.CharParsers.followedByNewline``1">
<summary>
 `followedByNewline` is an optimized implementation of `followedByL newline &quot;newline&quot;`.
</summary>
</member>
<member name="M:FParsec.CharParsers.notFollowedByEof``1">
<summary>
 `notFollowedByEOF` is an optimized implementation of `notFollowedByL eof &quot;end of input&quot;`.
</summary>
</member>
<member name="M:FParsec.CharParsers.puint8``1">
<summary>
 Parses an unsigned integer in decimal, hexadecimal (&quot;0x&quot; prefix), octal (&quot;0o&quot;) or binary (&quot;0b&quot;) format.
 The parser fails
 without consuming input, if not at least one digit (including the &apos;0&apos; in the format specifiers &quot;0x&quot; etc.) can be parsed,
 after consuming input, if no digit comes after an exponent marker or no hex digit comes after a format specifier,
 after consuming input, if the value represented by the input string is greater than 255.
</summary>
</member>
<member name="M:FParsec.CharParsers.puint16``1">
<summary>
 Parses an unsigned integer in decimal, hexadecimal (&quot;0x&quot; prefix), octal (&quot;0o&quot;) or binary (&quot;0b&quot;) format.
 The parser fails
 without consuming input, if not at least one digit (including the &apos;0&apos; in the format specifiers &quot;0x&quot; etc.) can be parsed,
 after consuming input, if no digit comes after an exponent marker or no hex digit comes after a format specifier,
 after consuming input, if the value represented by the input string is greater than `System.UInt16.MaxValue`.
</summary>
</member>
<member name="M:FParsec.CharParsers.puint32``1">
<summary>
 Parses an unsigned integer in decimal, hexadecimal (&quot;0x&quot; prefix), octal (&quot;0o&quot;) or binary (&quot;0b&quot;) format.
 The parser fails
 without consuming input, if not at least one digit (including the &apos;0&apos; in the format specifiers &quot;0x&quot; etc.) can be parsed,
 after consuming input, if no digit comes after an exponent marker or no hex digit comes after a format specifier,
 after consuming input, if the value represented by the input string is greater than `System.UInt32.MaxValue`.
</summary>
</member>
<member name="M:FParsec.CharParsers.puint64``1">
<summary>
 Parses an unsigned integer in decimal, hexadecimal (&quot;0x&quot; prefix), octal (&quot;0o&quot;) or binary (&quot;0b&quot;) format.
 The parser fails
 without consuming input, if not at least one digit (including the &apos;0&apos; in the format specifiers &quot;0x&quot; etc.) can be parsed,
 after consuming input, if no digit comes after an exponent marker or no hex digit comes after a format specifier,
 after consuming input, if the value represented by the input string is greater than `System.UInt64.MaxValue`.
</summary>
</member>
<member name="M:FParsec.CharParsers.pint8``1">
<summary>
 Parses an integer in decimal, hexadecimal (&quot;0x&quot; prefix), octal (&quot;0o&quot;) or binary (&quot;0b&quot;) format.
 The parser fails
 without consuming input, if not at least one digit (including the &apos;0&apos; in the format specifiers &quot;0x&quot; etc.) can be parsed,
 after consuming input, if no digit comes after an exponent marker or no hex digit comes after a format specifier,
 after consuming input, if the value represented by the input string is greater than 127 or less than -128.
</summary>
</member>
<member name="M:FParsec.CharParsers.pint16``1">
<summary>
 Parses an integer in decimal, hexadecimal (&quot;0x&quot; prefix), octal (&quot;0o&quot;) or binary (&quot;0b&quot;) format.
 The parser fails
 without consuming input, if not at least one digit (including the &apos;0&apos; in the format specifiers &quot;0x&quot; etc.) can be parsed,
 after consuming input, if no digit comes after an exponent marker or no hex digit comes after a format specifier,
 after consuming input, if the value represented by the input string is greater than `System.Int16.MaxValue` or less than `System.Int16.MinValue`.
</summary>
</member>
<member name="M:FParsec.CharParsers.pint32``1">
<summary>
 Parses an integer in decimal, hexadecimal (&quot;0x&quot; prefix), octal (&quot;0o&quot;) or binary (&quot;0b&quot;) format.
 The parser fails
 without consuming input, if not at least one digit (including the &apos;0&apos; in the format specifiers &quot;0x&quot; etc.) can be parsed,
 after consuming input, if no digit comes after an exponent marker or no hex digit comes after a format specifier,
 after consuming input, if the value represented by the input string is greater than `System.Int32.MaxValue` or less than `System.Int32.MinValue`.
</summary>
</member>
<member name="M:FParsec.CharParsers.pint64``1">
<summary>
 Parses an integer in decimal, hexadecimal (&quot;0x&quot; prefix), octal (&quot;0o&quot;) or binary (&quot;0b&quot;) format.
 The parser fails
 without consuming input, if not at least one digit (including the &apos;0&apos; in the format specifiers &quot;0x&quot; etc.) can be parsed,
 after consuming input, if no digit comes after an exponent marker or no hex digit comes after a format specifier,
 after consuming input, if the value represented by the input string is greater than `System.Int64.MaxValue` or less than `System.Int64.MinValue`.
</summary>
</member>
<member name="M:FParsec.CharParsers.pfloat``1">
<summary>
 Parses a floating-point number in decimal or hexadecimal format.
 The special values NaN and Inf(inity)? (case insensitive) are also recognized.

 The parser fails
 without consuming input, if not at least one digit (including the &apos;0&apos; in &quot;0x&quot;) can be parsed,
 after consuming input, if no digit comes after an exponent marker or no hex digit comes after &quot;0x&quot;,
 after consuming input, if the value represented by the input string (after rounding) is greater than `System.Double.MaxValue` or less than `System.Double.MinValue`.
</summary>
</member>
<member name="M:FParsec.CharParsers.numberLiteralE``1(FParsec.CharParsers.NumberLiteralOptions,FParsec.ErrorMessageList,FParsec.CharStream{``0})">
<summary>
 `numberLiteralE` is an uncurried version of `numberLiteral` that can be used to
 implement number parsers without having to construct a `numberLiteral` closure.
</summary>
</member>
<member name="M:FParsec.CharParsers.numberLiteral``1(FParsec.CharParsers.NumberLiteralOptions,System.String)">
<summary>
 `numberLiteral options label` parses a number literal and returns the result in form
 of a `NumberLiteral` value. The given `NumberLiteralOptions` argument determines the kind
 of number literals accepted. The string `label` is used in the `Expected` error message
 that is generated when the parser fails without consuming input.

 The parser fails without consuming input, if not at least one digit (including the 0 in the
 format specifiers &quot;0x&quot; etc.) can be parsed. It fails after consuming input, if no decimal
 digit comes after an exponent marker or no valid digit comes after a format specifier.
</summary>
</member>
<member name="M:FParsec.CharParsers.withSkippedString``3(Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``2},FParsec.Reply{``0}})">
<summary>
 `p |&gt; withSkippedString f` applies the parser `p` and returns the result of `f str x`,
 where `str` is the string skipped over by `p` and `x` is the result returned by `p`.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipped``1(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``0},FParsec.Reply{Microsoft.FSharp.Core.Unit}})">
<summary>
 `skipped p` applies the parser `p` and returns the chars skipped over by `p` as a string.
 All newlines (&quot;\r\n&quot;, &quot;\r&quot; or &quot;\n&quot;) are normalized to &quot;\n&quot;.
</summary>
</member>
<member name="M:FParsec.CharParsers.stringsSepBy1``1(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``0},FParsec.Reply{System.String}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``0},FParsec.Reply{System.String}})">
<summary>
 `stringsSepBy1 sp sep` parses *one* or more occurrences of `sp` separated by `sep`.
 It returns the strings parsed by `sp` *and* `sep` in concatenated form.
</summary>
</member>
<member name="M:FParsec.CharParsers.stringsSepBy``1(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``0},FParsec.Reply{System.String}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``0},FParsec.Reply{System.String}})">
<summary>
 `stringsSepBy sp sep` parses *zero* or more occurrences of `sp` separated by `sep`.
 It returns the strings parsed by `sp` *and* `sep` in concatenated form.
</summary>
</member>
<member name="M:FParsec.CharParsers.many1Strings2``1(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``0},FParsec.Reply{System.String}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``0},FParsec.Reply{System.String}})">
<summary>
 `many1Strings2 sp1 sp` behaves like `many1Strings sp`, except that it parses the first string with `sp1` instead of `sp`.
</summary>
</member>
<member name="M:FParsec.CharParsers.many1Strings``1(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``0},FParsec.Reply{System.String}})">
<summary>
 `many1Strings sp` parses a sequence of *one* or more strings with the string parser `sp`.
 It returns the strings in concatenated form.
 Note that `many1Strings sp` does not require the first string to be non-empty.
</summary>
</member>
<member name="M:FParsec.CharParsers.manyStrings2``1(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``0},FParsec.Reply{System.String}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``0},FParsec.Reply{System.String}})">
<summary>
 `manyStrings2 sp1 sp` behaves like `manyStrings sp`, except that it parses the first string with `sp1` instead of `sp`.
</summary>
</member>
<member name="M:FParsec.CharParsers.manyStrings``1(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``0},FParsec.Reply{System.String}})">
<summary>
 `manyStrings sp` parses a sequence of *zero* or more strings with the string parser `sp`.
 It returns the strings in concatenated form.
 `manyStrings sp` is an optimized implementation of `manyReduce (+) &quot;&quot; sp`.
</summary>
</member>
<member name="M:FParsec.CharParsers.many1CharsTillApply2``3(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``0},FParsec.Reply{System.Char}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``0},FParsec.Reply{System.Char}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``0},FParsec.Reply{``1}},Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpFunc{``1,``2}})">
<summary>
 `many1CharsTillApply2 cp1 cp endp` behaves like `many1CharsTillApply cp endp`, except that it parses the first char with `cp1` instead of `cp`.
</summary>
</member>
<member name="M:FParsec.CharParsers.many1CharsTillApply``3(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``0},FParsec.Reply{System.Char}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``0},FParsec.Reply{``1}},Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpFunc{``1,``2}})">
<summary>
 `many1CharsTillApply cp endp` parses one char with the char parser `cp`.
 Then it parses more chars with `cp` until the parser `endp` succeeds.
 It stops after `endp` and returns the result of the function application `f str b`,
 where `str` is the parsed string and `b` is result returned by `endp`.
</summary>
</member>
<member name="M:FParsec.CharParsers.many1CharsTill2``2(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``0},FParsec.Reply{System.Char}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``0},FParsec.Reply{System.Char}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``0},FParsec.Reply{``1}})">
<summary>
 `many1CharsTill2 cp1 cp endp` behaves like `many1CharsTill cp endp`, except that it parses the first char with `cp1` instead of `cp`.
</summary>
</member>
<member name="M:FParsec.CharParsers.many1CharsTill``2(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``0},FParsec.Reply{System.Char}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``0},FParsec.Reply{``1}})">
<summary>
 `many1CharsTill cp endp` parses one char with the char parser `cp`.
 Then it parses more chars with `cp` until the parser `endp` succeeds.
 It stops after `endp` and returns the parsed chars as a string.

 `many1CharsTill cp endp` is an optimized implementation of `pipe2 cp (manyCharsTill cp endp) (fun c1 str -&gt; c1.ToString() + str)`
</summary>
</member>
<member name="M:FParsec.CharParsers.manyCharsTillApply2``3(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``0},FParsec.Reply{System.Char}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``0},FParsec.Reply{System.Char}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``0},FParsec.Reply{``1}},Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpFunc{``1,``2}})">
<summary>
 `manyCharsTillApply2 cp1 cp endp` behaves like `manyCharsTillApply cp endp`, except that it parses the first char with `cp1` instead of `cp`.
</summary>
</member>
<member name="M:FParsec.CharParsers.manyCharsTillApply``3(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``0},FParsec.Reply{System.Char}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``0},FParsec.Reply{``1}},Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpFunc{``1,``2}})">
<summary>
 `manyCharsTillApply cp endp f` parses chars with the char parser `cp` until the parser `endp` succeeds.
 It stops after `endp` and returns the result of the function application `f str b`,
 where `str` is the parsed string and `b` is result returned by `endp`.
</summary>
</member>
<member name="M:FParsec.CharParsers.manyCharsTill2``2(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``0},FParsec.Reply{System.Char}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``0},FParsec.Reply{System.Char}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``0},FParsec.Reply{``1}})">
<summary>
 `manyCharsTill2 cp1 cp endp` behaves like `manyCharsTill cp endp`, except that it parses the first char with `cp1` instead of `cp`.
</summary>
</member>
<member name="M:FParsec.CharParsers.manyCharsTill``2(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``0},FParsec.Reply{System.Char}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``0},FParsec.Reply{``1}})">
<summary>
 `manyCharsTill cp endp` parses chars with the char parser `cp` until the parser `endp` succeeds.
 It stops after `endp` and returns the parsed chars as a string.
</summary>
</member>
<member name="M:FParsec.CharParsers.many1Chars2``1(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``0},FParsec.Reply{System.Char}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``0},FParsec.Reply{System.Char}})">
<summary>
 `many1Chars2 cp1 cp` behaves like `many1Chars2 cp`, except that it parses the first char with `cp1` instead of `cp`.
</summary>
</member>
<member name="M:FParsec.CharParsers.many1Chars``1(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``0},FParsec.Reply{System.Char}})">
<summary>
 `many1Chars cp` parses a sequence of *one* or more chars with the char parser `cp`.
 It returns the parsed chars as a string.

 `many1Chars cp` is an optimized implementation of `many1 (attempt cp)` that returns
 the chars as a string instead of a char list.  The equivalence to `many1 (attempt p)`
 instead of `many1 p` implies that  `many1Chars` never fails after consuming input.
</summary>
</member>
<member name="M:FParsec.CharParsers.manyChars2``1(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``0},FParsec.Reply{System.Char}},Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``0},FParsec.Reply{System.Char}})">
<summary>
 `manyChars2 cp1 cp` behaves like `manyChars2 cp`, except that it parses the first char with `cp1` instead of `cp`.
</summary>
</member>
<member name="M:FParsec.CharParsers.manyChars``1(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``0},FParsec.Reply{System.Char}})">
<summary>
 `manyChars cp` parses a sequence of *zero* or more chars with the char parser `cp`.
 It returns the parsed chars as a string.

 `manyChars cp` is an optimized implementation of `many (attempt cp)` that returns
 the chars as a string instead of a char list.  The equivalence to `many (attempt p)`
  instead of `many p` implies that `manyChars` never fails.
</summary>
</member>
<member name="M:FParsec.CharParsers.identifier``1(FParsec.CharParsers.IdentifierOptions)">
<summary>
 The `identifier` parser is a configurable parser for the XID identifier syntax
 specified in Unicode Standard Annex #31.
</summary>
</member>
<member name="M:FParsec.CharParsers.regexL``1(System.String,System.String)">
<summary>
 `regexL pattern label` is an optimized implementation of `regex pattern &lt;?&gt; label`.
</summary>
</member>
<member name="M:FParsec.CharParsers.regex``1(System.String)">
<summary>
 `regex pattern` matches the .NET regular expression given by the string `pattern` on the chars
 beginning at the current index in the input stream. It returns the string matched by the regular expression.
 If the regular expression does not match, the parser fails without consuming input.

 The `System.Text.RegularExpressions.Regex` object that is internally used to match the pattern is constructed
 with the `RegexOptions` `MultiLine` and `ExplicitCapture`. In order to ensure that the regular expression
 can only match at the beginning of a string, &quot;\\A&quot; is automatically prepended to the pattern.

 Newline chars (&apos;\r&apos; and &apos;\n&apos;) in the pattern are interpreted literally.
 For example, an &apos;\n&apos; char in the pattern will only match &quot;\n&quot;, not &quot;\r&quot; or &quot;\r\n&quot;.
 However, in the returned string all newlines (&quot;\n&quot;, &quot;\r\n&quot; or &quot;\r&quot;) are normalized to &quot;\n&quot;.

 For large files the regular expression is *not* applied to a string containing *all* the remaining chars
 in the stream. The number of chars that are guaranteed to be visible to the regular expression is specified
 during construction of the `CharStream`. If one of the `runParser` function` is used to run the parser,
 this number is 43690.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipManyMinMaxSatisfy2L``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},System.String)">
<summary>
 `skipManyMinMaxSatisfy2L minCount maxCount f1 f label` is an optimized implementation of `skipManyMinMaxSatisfy2 minCount maxCount f1 f &lt;?&gt; label`.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipManyMinMaxSatisfyL``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},System.String)">
<summary>
 `skipManyMinMaxSatisfyL minCount maxCount f label` is an optimized implementation of `skipManyMinMaxSatisfy minCount maxCount f &lt;?&gt; label`.
</summary>
</member>
<member name="M:FParsec.CharParsers.manyMinMaxSatisfy2L``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},System.String)">
<summary>
 `manyMinMaxSatisfy2L minCount maxCount f1 f label` is an optimized implementation of `manyMinMaxSatisfy2 minCount maxCount f1 f &lt;?&gt; label`.
</summary>
</member>
<member name="M:FParsec.CharParsers.manyMinMaxSatisfyL``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},System.String)">
<summary>
 `manyMinMaxSatisfyL minCount maxCount f label` is an optimized implementation of `manyMinMaxSatisfy minCount maxCount f &lt;?&gt; label`.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipManyMinMaxSatisfy2``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean})">
<summary>
 `skipManyMinMaxSatisfy2 minCount maxCount f1 f` is an optimized implementation of `manyMinMaxSatisfy2 minCount maxCount f1 f |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipManyMinMaxSatisfy``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean})">
<summary>
 `skipManyMinMaxSatisfy minCount maxCount f` is an optimized implementation of `manyMinMaxSatisfy minCount maxCount f |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.manyMinMaxSatisfy2``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean})">
<summary>
 `manyMinMaxSatisfy2 minCount maxCount f1 f` behaves like `manyMinMaxSatisfy minCount maxCount f`, except that the first char of the parsed string must satisfy `f1` instead of `f`.
</summary>
</member>
<member name="M:FParsec.CharParsers.manyMinMaxSatisfy``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean})">
<summary>
 `manyMinMaxSatisfy minCount maxCount f` parses a sequence of `minCount` or more chars that satisfy the
 predicate function `f` (i.e. chars for which `f` returns `true`), but not more than `maxCount` chars.
 It returns the parsed chars as a string. This parser is atomic, i.e. if the first `minCount` chars
 do not all satisfy `f`, the parser fails without consuming any input.

 Any newline (&quot;\n&quot;, &quot;\r\n&quot; or &quot;\r&quot;) is converted to the single char &apos;\n&apos;.
 Thus, to accept a newline `f &apos;\n&apos;` must return `true`. `f` will never be called with &apos;\r&apos;
 and the string returned by `manyMinMaxSatisfy minCount maxCount f` will never contain an &apos;\r&apos;.

 `manyMinMaxSatisfy` throws an `ArgumentOutOfRangeException` if `maxCount` is negative.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipMany1Satisfy2L``1(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},System.String)">
<summary>
 `skipMany1Satisfy2L f1 f label` is an optimized implementation of `skipMany1Satisfy2 f1 f &lt;?&gt; label`.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipMany1SatisfyL``1(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},System.String)">
<summary>
 `skipMany1SatisfyL f label` is an optimized implementation of `skipMany1Satisfy f &lt;?&gt; label`.
</summary>
</member>
<member name="M:FParsec.CharParsers.many1Satisfy2L``1(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},System.String)">
<summary>
 `many1Satisfy2L f1 f label` is an optimized implementation of `many1Satisfy2 f1 f &lt;?&gt; label`.
</summary>
</member>
<member name="M:FParsec.CharParsers.many1SatisfyL``1(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},System.String)">
<summary>
 `many1SatisfyL f label` is an optimized implementation of `many1Satisfy f &lt;?&gt; label`.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipMany1Satisfy2``1(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean})">
<summary>
 `skipMany1Satisfy2 f1 f` is an optimized implementation of `many1Satisfy2 f1 f |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipMany1Satisfy``1(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean})">
<summary>
 `skipMany1Satisfy f` is an optimized implementation of `many1Satisfy f |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.many1Satisfy2``1(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean})">
<summary>
 `many1Satisfy2 f1 f` behaves like `many1Satisfy f`, except that the
 first char of the parsed string must satisfy `f1` instead of `f`.
</summary>
</member>
<member name="M:FParsec.CharParsers.many1Satisfy``1(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean})">
<summary>
 `many1Satisfy f` parses a sequence of *one* or more chars that satisfy the predicate function `f`
 (i.e. chars for which `f` returns `true`). It returns the parsed chars as a string.
 If the first char does not satisfy `f`, this parser fails without consuming input.

 Any newline (&quot;\n&quot;, &quot;\r\n&quot; or &quot;\r&quot;) is converted to the single char &apos;\n&apos;.
 Thus, to accept a newline `f &apos;\n&apos;` must return `true`. `f` will never be called
 with &apos;\r&apos; and the string returned by `many1Satisfy f` will never contain an &apos;\r&apos;.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipManySatisfy2``1(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean})">
<summary>
 `skipManySatisfy2 f1 f` is an optimized implementation of `manySatisfy2 f1 f |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipManySatisfy``1(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean})">
<summary>
 `skipManySatisfy f` is an optimized implementation of `manySatisfy f |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.manySatisfy2``1(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean})">
<summary>
 `manySatisfy2 f1 f` behaves like `manySatisfy f`, except that the
 first char of the parsed string must satisfy `f1` instead of `f`.
</summary>
</member>
<member name="M:FParsec.CharParsers.manySatisfy``1(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean})">
<summary>
 `manySatisfy f` parses a sequence of *zero* or more chars that satisfy the predicate function `f`
 (i.e.  chars for which `f` returns `true`). It returns the parsed chars as a string.

 Any newline (&quot;\n&quot;, &quot;\r\n&quot; or &quot;\r&quot;) is converted to the single char &apos;\n&apos;.
 Thus, to accept a newline `f &apos;\n&apos;` must return `true`. `f` will never be called
 with &apos;\r&apos; and the string returned by `manySatisfy f` will never contain an &apos;\r&apos;.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipCharsTillStringCI``1(System.String,System.Boolean,System.Int32)">
<summary>
 `skipCharsTillStringCI str maxCount` is an optimized implementation of `charsTillStringCI str maxCount |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.charsTillStringCI``1(System.String,System.Boolean,System.Int32)">
<summary>
 `charsTillStringCI str skipString maxCount` parses all chars before the first case-insensitive occurance of the string `str` and,
 if `skipString` is `true`, skips over it. It returns the parsed chars before the string.
 If more than `maxCount` chars come before the first case-insensitive occurance of `str`,
 the parser *fails* after consuming `maxCount` chars.
 Newlines (&quot;\n&quot;, &quot;\r\n&quot; or &quot;\r&quot;) are counted as single chars and
 in the returned string all newlines are normalized to &quot;\n&quot;.
 `charsTillStringCI str maxCount` throws an `ArgumentOutOfRangeException` if `maxCount` is negative.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipCharsTillString``1(System.String,System.Boolean,System.Int32)">
<summary>
 `skipCharsTillString str maxCount` is an optimized implementation of `charsTillString str maxCount |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.charsTillString``1(System.String,System.Boolean,System.Int32)">
<summary>
 `charsTillString str skipString maxCount` parses all chars before the first occurance of the string `str` and,
 if `skipString` is `true`, skips over `str`. It returns the parsed chars before the string.
 If more than `maxCount` chars come before the first occurance of `str`, the parser *fails after consuming* `maxCount` chars.
 Newlines (&quot;\n&quot;, &quot;\r\n&quot; or &quot;\r&quot;) are counted as single chars and
 in the returned string all newlines are normalized to &quot;\n&quot;.
 `charsTillString str maxCount` throws an `ArgumentOutOfRangeException` if `maxCount` is negative.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipRestOfLine``1(System.Boolean)">
<summary>
 `skipRestOfLine skipNewline` is an optimized implementation of `restOfLine skipNewline |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.restOfLine``1(System.Boolean)">
<summary>
 `restOfLine skipNewline` parses any chars before the end of the line
 and, if `skipNewline` is `true`, skips to the beginning of the next line (if there is one).
 It returns the parsed chars before the end of the line as a string (without a newline).
 A line is terminated by a newline (&quot;\n&quot;, &quot;\r\n&quot; or &quot;\r&quot;) or the end of the input stream.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipAnyString``1(System.Int32)">
<summary>
 `skipAnyString n` is an optimized implementation of `anyString n |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.anyString``1(System.Int32)">
<summary>
 `anyString n` parses any sequence of `n` chars or newlines (&quot;\n&quot;, &quot;\r\n&quot; or &quot;\r&quot;).
 It returns the parsed string. In the returned string all newlines are normalized to &quot;\n&quot;.
 `anyString n` is an atomic parser: either it succeeds or it fails without consuming any input.
</summary>
</member>
<member name="M:FParsec.CharParsers.stringCIReturn``2(System.String,``0)">
<summary>
 `stringCIReturn str x` is an optimized implementation of `pstringCI str &gt;&gt;% x`.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipStringCI``1(System.String)">
<summary>
 `skipStringCI str` is an optimized implementation of `pstringCI str |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.pstringCI``1(System.String)">
<summary>
 `pstringCI str` parses any string that case-insensitively matches the string `str`.
 It returns the *parsed* string.
 `str` may not contain newline chars (&apos;\n&apos; or &apos;\r&apos;).
</summary>
</member>
<member name="M:FParsec.CharParsers.stringReturn``2(System.String,``0)">
<summary>
 `stringReturn str x` is an optimized implementation of `pstring str &gt;&gt;% x`.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipString``1(System.String)">
<summary>
 `skipString str` is an optimized implementation of `pstring str |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.pstring``1(System.String)">
<summary>
 `pstring str` parses the string `str` and returns `str`.
 It is an atomic parser: either it succeeds or it fails without consuming any input.
 `str` may not contain newline chars (&apos;\n&apos; or &apos;\r&apos;).
</summary>
</member>
<member name="M:FParsec.CharParsers.eof``1">
<summary>
 The parser `eof` only succeeds at the end of the input. It never consumes input.
</summary>
</member>
<member name="M:FParsec.CharParsers.unicodeSpaces1``1">
<summary>
 Skips over any sequence of *one* or more unicode whitespaces and
 registers any unicode newline (&quot;\n&quot;, &quot;\r\n&quot;, &quot;\r&quot;, &quot;\u0085, &quot;\u000C&quot;,
 &quot;\u2028&quot;or &quot;\u2029&quot;) as a newline.
</summary>
</member>
<member name="M:FParsec.CharParsers.unicodeSpaces``1">
<summary>
 Skips over any sequence of *one* or more unicode whitespaces and
 registers any unicode newline (&quot;\n&quot;, &quot;\r\n&quot;, &quot;\r&quot;, &quot;\u0085, &quot;\u000C&quot;,
 &quot;\u2028&quot;or &quot;\u2029&quot;) as a newline.
</summary>
</member>
<member name="M:FParsec.CharParsers.spaces1``1">
<summary>
 Skips over any sequence of *one* or more whitespaces (space (&apos; &apos;), tab(&apos;\t&apos;)
 or newline (&quot;\n&quot;, &quot;\r\n&quot; or &quot;\r&quot;)).
</summary>
</member>
<member name="M:FParsec.CharParsers.spaces``1">
<summary>
 Skips over any sequence of *zero* or more whitespaces (space (&apos; &apos;), tab (&apos;\t&apos;)
 or newline (&quot;\n&quot;, &quot;\r\n&quot; or &quot;\r&quot;)).
</summary>
</member>
<member name="M:FParsec.CharParsers.unicodeNewlineReturn``2(``0)">
<summary>
 `newlineReturn x` is an optimized implementation of `unicodeNewline &gt;&gt;% x`.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipUnicodeNewline``1">
<summary>
 `skipNewline` is an optimized implementation of `unicodeNewline |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.unicodeNewline``1">
<summary>
 Parses a unicode newline (&quot;\n&quot;, &quot;\r\n&quot;, &quot;\r&quot;, &quot;\u0085&quot;, &quot;\u2028&quot;, or &quot;\u2029&quot;).
 Returns &apos;\n&apos;. Note that this parser does not accept the formfeed char &apos;\f&apos; as a newline.
 In contrast to most other parsers in FParsec this parser also increments
 the internal line count for unicode newline characters other than &apos;\n&apos; and &apos;\r&apos;.
</summary>
</member>
<member name="M:FParsec.CharParsers.newlineReturn``2(``0)">
<summary>
 `newlineReturn x` is an optimized implementation of `newline &gt;&gt;% x`.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipNewline``1">
<summary>
 `skipNewline` is an optimized implementation of `newline |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.newline``1">
<summary>
 Parses a newline (&quot;\n&quot;, &quot;\r\n&quot; or &quot;\r&quot;). Returns &apos;\n&apos;.
 Is equivalent to `pchar &apos;\n&apos;`.
</summary>
</member>
<member name="M:FParsec.CharParsers.tab``1">
<summary>
 Parses the tab char &apos;\t&apos; and returns &apos;\t&apos;. Note that a tab char is treated like any other non-newline char:
 the column number is incremented by (only) 1.
</summary>
</member>
<member name="M:FParsec.CharParsers.isOctal(System.Char)">
<summary>
 Returns `true` for any char in the range &apos;0&apos; - &apos;7&apos; and `false` for all other chars.
</summary>
</member>
<member name="M:FParsec.CharParsers.isHex(System.Char)">
<summary>
 Returns `true` for any char in the range &apos;0&apos; - &apos;9&apos;, &apos;a&apos; - &apos;f&apos;, &apos;A&apos; - &apos;F&apos; and `false` for all other chars.
</summary>
</member>
<member name="M:FParsec.CharParsers.isDigit(System.Char)">
<summary>
 Returns `true` for any char in the range &apos;0&apos; - &apos;9&apos; and `false` for all other chars.
</summary>
</member>
<member name="M:FParsec.CharParsers.isLetter(System.Char)">
<summary>
 `isLetter` is equivalent to `System.Char.IsLetter`.
</summary>
</member>
<member name="M:FParsec.CharParsers.isLower(System.Char)">
<summary>
 `isLower` is equivalent to `System.Char.IsLower`.
</summary>
</member>
<member name="M:FParsec.CharParsers.isUpper(System.Char)">
<summary>
 `isUpper` is equivalent to `System.Char.IsUpper`.
</summary>
</member>
<member name="M:FParsec.CharParsers.isAsciiLetter(System.Char)">
<summary>
 Returns `true` for any char in the range &apos;a&apos; - &apos;z&apos;, &apos;A&apos; - &apos;Z&apos; and `false` for all other chars.
</summary>
</member>
<member name="M:FParsec.CharParsers.isAsciiLower(System.Char)">
<summary>
 Returns `true` for any char in the range &apos;a&apos; - &apos;z&apos; and `false` for all other chars.
</summary>
</member>
<member name="M:FParsec.CharParsers.isAsciiUpper(System.Char)">
<summary>
 Returns `true` for any char in the range &apos;A&apos; - &apos;Z&apos; and `false` for all other chars.
</summary>
</member>
<member name="M:FParsec.CharParsers.isNoneOf(System.Collections.Generic.IEnumerable{System.Char})">
<summary>
 `isNoneOf str` returns a predicate function.
 When this predicate function is applied to a char, it returns `true` if and only if the char is not contained in `str`.
</summary>
</member>
<member name="M:FParsec.CharParsers.isAnyOf(System.Collections.Generic.IEnumerable{System.Char})">
<summary>
 `isAnyOf str` returns a predicate function.
 When this predicate function is applied to a char, it returns `true` if and only if the char is contained in `str`.
</summary>
</member>
<member name="M:FParsec.CharParsers.octal``1">
<summary>
 Parses any char in the range &apos;0&apos; - &apos;7&apos;. Returns the parsed char.
</summary>
</member>
<member name="M:FParsec.CharParsers.hex``1">
<summary>
 Parses any char in the range &apos;0&apos; - &apos;9&apos;, &apos;a&apos; - &apos;f&apos; and &apos;A&apos; - &apos;F&apos;. Returns the parsed char.
</summary>
</member>
<member name="M:FParsec.CharParsers.digit``1">
<summary>
 Parses any char in the range &apos;0&apos; - &apos;9&apos;. Returns the parsed char.
</summary>
</member>
<member name="M:FParsec.CharParsers.letter``1">
<summary>
 Parses any UTF-16 letter char identified by `System.Char.IsLetter`.
 Returns the parsed char.
</summary>
</member>
<member name="M:FParsec.CharParsers.lower``1">
<summary>
 Parses any UTF-16 lowercase letter char identified by `System.Char.IsLower`.
 Returns the parsed char.
</summary>
</member>
<member name="M:FParsec.CharParsers.upper``1">
<summary>
 Parses any UTF-16 uppercase letter char identified by `System.Char.IsUpper`.
 Returns the parsed char.
</summary>
</member>
<member name="M:FParsec.CharParsers.asciiLetter``1">
<summary>
 Parses any char in the range &apos;a&apos; - &apos;z&apos; and &apos;A&apos; - &apos;Z&apos;. Returns the parsed char.
</summary>
</member>
<member name="M:FParsec.CharParsers.asciiLower``1">
<summary>
 Parses any char in the range &apos;a&apos; - &apos;z&apos;. Returns the parsed char.
</summary>
</member>
<member name="M:FParsec.CharParsers.asciiUpper``1">
<summary>
 Parses any char in the range &apos;A&apos; - &apos;Z&apos;. Returns the parsed char.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipNoneOf``1(System.Collections.Generic.IEnumerable{System.Char})">
<summary>
 `skipNoneOf s` is an optimized implementation of `noneOf s |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.noneOf``1(System.Collections.Generic.IEnumerable{System.Char})">
<summary>
 `noneOf str` parses any char not contained in the string `str`. It returns the parsed char.
 If `str` does not contain the char &apos;\n&apos;, `noneOf str` parses any newline (&quot;\n&quot;, &quot;\r\n&quot; or &quot;\r&quot;)
 and returns it as  as &apos;\n&apos;. (Note that it does not make a difference whether or not
 `str` contains &apos;\r&apos;; `noneOf str` will never return &apos;\r&apos;.)
</summary>
</member>
<member name="M:FParsec.CharParsers.skipAnyOf``1(System.Collections.Generic.IEnumerable{System.Char})">
<summary>
 `skipAnyOf str` is an optimized implementation of `anyOf str |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.anyOf``1(System.Collections.Generic.IEnumerable{System.Char})">
<summary>
 `anyOf str` parses any char contained in the string `str`. It returns the parsed char.
 If `str` contains the char &apos;\n&apos;, `anyOf str` parses any newline (&quot;\n&quot;, &quot;\r\n&quot; or &quot;\r&quot;)
 and returns it as &apos;\n&apos;. (Note that it does not make a difference whether or not
 `str` contains &apos;\r&apos;; `anyOf str` will never return &apos;\r&apos;.)
</summary>
</member>
<member name="M:FParsec.CharParsers.skipSatisfyL``1(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},System.String)">
<summary>
 `skipSatisfyL f label` is an optimized implementation of `skipSatisfy f &lt;?&gt; label`.
</summary>
</member>
<member name="M:FParsec.CharParsers.satisfyL``1(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},System.String)">
<summary>
 `satisfy f label` is an optimized implementation of `satisfy f &lt;?&gt; label`.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipSatisfy``1(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean})">
<summary>
 `skipSatisfy f` is an optimized implementation of `satisfy f |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.satisfy``1(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean})">
<summary>
 `satisfy f` parses any one char or newline for which the predicate function `f` returns `true`.
 It returns the parsed char.
 Any newline (&quot;\n&quot;, &quot;\r\n&quot; or &quot;\r&quot;) is converted to the single char &apos;\n&apos;.
 Thus, to accept a newline `f &apos;\n&apos;` must return `true`. `f` will never be called
 with &apos;\r&apos; and `satisfy f` will never return the result &apos;\r&apos;.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipAnyChar``1">
<summary>
 `skipAnyChar` is an optimized implementation of `anyChar |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.anyChar``1">
<summary>
 `anyChar` parses any single char or newline (&quot;\n&quot;, &quot;\r\n&quot; or &quot;\r&quot;).
 Returns the parsed char, or &apos;\n&apos; in case a newline was parsed.
</summary>
</member>
<member name="M:FParsec.CharParsers.charReturn``2(System.Char,``0)">
<summary>
 `charReturn c x` is an optimized implementation of `pchar c &gt;&gt;% x`.
</summary>
</member>
<member name="M:FParsec.CharParsers.skipChar``1(System.Char)">
<summary>
 `skipChar c` is an optimized implementation of `pchar c |&gt;&gt; ignore`.
</summary>
</member>
<member name="M:FParsec.CharParsers.pchar``1(System.Char)">
<summary>
 `pchar c` parses the char `c` and returns `c`.
 If `c = &apos;\r&apos;` or `c = &apos;\n&apos;` then `pchar c` will parse any one newline (&quot;\n&quot;, &quot;\r\n&quot; or &quot;\r&quot;) and return `c`.
</summary>
</member>
<member name="M:FParsec.CharParsers.userStateSatisfies``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean})">
<summary>
 The parser `userStateSatisfies f` succeeds if `f` returns `true`
 when applied to the current user state, otherwise it fails.
</summary>
</member>
<member name="M:FParsec.CharParsers.updateUserState``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0})">
<summary>
 `updateUserState f` is equivalent to `fun stream -&gt; stream.UserState &lt;- f stream.UserState; Reply(())`.
</summary>
</member>
<member name="M:FParsec.CharParsers.setUserState``1(``0)">
<summary>
 The parser `setUserState u` sets the user state to `u`.
 `setUserState u` is equivalent to `fun stream -&gt; stream.UserState &lt;- u; Reply(())`.
</summary>
</member>
<member name="M:FParsec.CharParsers.getUserState``1">
<summary>
 The parser `getUserState` returns the current user state.
 `getUserState` is equivalent to `fun stream -&gt; Reply(stream.UserState)`.
</summary>
</member>
<member name="M:FParsec.CharParsers.getPosition``1">
<summary>
 The parser `getPosition` returns the current position in the input Stream.
 `getPosition` is equivalent to `fun stream -&gt; Reply(stream.Position)`.
</summary>
</member>
<member name="M:FParsec.CharParsers.run``1(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{Microsoft.FSharp.Core.Unit},FParsec.Reply{``0}},System.String)">
<summary>
 `run parser str` is a convenient abbreviation for `runParserOnString parser () &quot;&quot; str`.
</summary>
</member>
<member name="M:FParsec.CharParsers.runParserOnFile``2(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},``1,System.String,System.Text.Encoding)">
<summary>
 `runParserOnFile p ustate path encoding` runs the parser `p` on the content of the file
 at the given `path`, starting with the initial user state `ustate`.
 In case no unicode byte order mark is found, the file data is assumed to be encoded with the given `encoding`.
 The parser&apos;s `Reply` is captured and returned as a `ParserResult` value.
</summary>
</member>
<member name="M:FParsec.CharParsers.runParserOnStream``2(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},``1,System.String,System.IO.Stream,System.Text.Encoding)">
<summary>
 `runParserOnStream p ustate streamName stream encoding` runs the parser `p` on the content of
 the `System.IO.Stream` `stream`, starting with the initial user state `ustate`. The `streamName`
 is used in error messages to describe the source of the input (e.g. a file path) and may be empty.
 In case no unicode byte order mark is found, the stream data is assumed to be encoded with the given `encoding`.
 The parser&apos;s `Reply` is captured and returned as a `ParserResult` value.
</summary>
</member>
<member name="M:FParsec.CharParsers.runParserOnSubstring``2(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},``1,System.String,System.String,System.Int32,System.Int32)">
<summary>
 `runParserOnSubstring p ustate streamName str index count` runs the parser `p` directly on the content
 of the string `str` between the indices `index` (inclusive) and `index + count` (exclusive),
 starting with the initial user state `ustate`. The `streamName` is used in error messages to describe
 the source of the input (e.g. a file path) and may be empty.
 The parser&apos;s `Reply` is captured and returned as a `ParserResult` value.
</summary>
</member>
<member name="M:FParsec.CharParsers.runParserOnString``2(Microsoft.FSharp.Core.FSharpFunc{FParsec.CharStream{``1},FParsec.Reply{``0}},``1,System.String,System.String)">
<summary>
 `runParserOnString p ustate streamName str` runs the parser `p` directly on the content of the string `str`,
 starting with the initial user state `ustate`. The `streamName` is used in error messages to describe
 the source of the input (e.g. a file path) and may be empty.
 The parser&apos;s `Reply` is captured and returned as a `ParserResult` value.
</summary>
</member>
</members>
</doc>
